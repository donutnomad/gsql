//go:build ignore

//go:generate go run gen.go

package main

import (
	"bytes"
	"go/format"
	"os"
	"text/template"
)

type FieldType struct {
	Name      string // e.g., "IntField"
	InnerExpr string // e.g., "Int"
	InnerName string // e.g., "Int" (field name in struct)
}

var fieldTypes = []FieldType{
	{"IntField", "Int", "Int"},
	{"FloatField", "Float", "Float"},
	{"DecimalField", "Decimal", "Decimal"},
	{"StringField", "String", "String"},
	{"DateTimeField", "DateTime", "DateTime"},
	{"DateField", "Date", "Date"},
	{"TimeField", "Time", "Time"},
	{"ScalarField", "Scalar", "Scalar"},
}

const tpl = `// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/field"
	"github.com/donutnomad/gsql/internal/types"
)

{{range .}}
// ==================== {{.Name}} ====================

type {{.Name}}[T any] struct {
	field.Base
	{{.InnerName}}[T]
}

func New{{.Name}}[T any](tableName, name string, flags ...field.FieldFlag) {{.Name}}[T] {
	b := field.NewBase(tableName, name, flags...)
	return New{{.Name}}From[T](b)
}

func New{{.Name}}From[T any](f field.IField) {{.Name}}[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return {{.Name}}[T]{
		Base:      base,
		{{.InnerName}}: New{{.InnerExpr}}[T](expr),
	}
}

func (f {{.Name}}[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f {{.Name}}[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f {{.Name}}[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f {{.Name}}[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) {{.Name}}[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return New{{.Name}}[T](tableName.TableName(), name)
}

func (f {{.Name}}[T]) WithAlias(alias string) {{.Name}}[T] {
	b := f.Base.SetAlias(alias)
	return New{{.Name}}From[T](b)
}

func (f {{.Name}}[T]) FieldType() T {
	var def T
	return def
}

func (f {{.Name}}[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f {{.Name}}[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}
{{end}}
`

func main() {
	t := template.Must(template.New("fields").Parse(tpl))

	var buf bytes.Buffer
	if err := t.Execute(&buf, fieldTypes); err != nil {
		panic(err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// 如果格式化失败，输出原始内容以便调试
		os.WriteFile("field_gen.go", buf.Bytes(), 0644)
		panic(err)
	}

	if err := os.WriteFile("field_gen.go", formatted, 0644); err != nil {
		panic(err)
	}
}
