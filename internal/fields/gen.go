//go:build ignore

//go:generate go run gen.go

package main

import (
	"bytes"
	"go/format"
	"os"
	"strings"
	"text/template"
)

type FieldType struct {
	Name      string // e.g., "IntField"
	InnerExpr string // e.g., "IntExpr"
	InnerName string // e.g., "IntExpr" (field name in struct)
}

var fieldTypes = []FieldType{
	newFieldType("IntExpr"),
	newFieldType("FloatExpr"),
	newFieldType("DecimalExpr"),
	newFieldType("StringExpr"),
	newFieldType("DateTimeExpr"),
	newFieldType("DateExpr"),
	newFieldType("TimeExpr"),
	newFieldType("ScalarExpr"),
}

func newFieldType(input string) FieldType {
	a := strings.TrimSuffix(input, "Expr") + "Field"
	return FieldType{a, input, input}
}

const tpl = `// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/clauses2"
	"github.com/donutnomad/gsql/internal/fieldi"
	"github.com/donutnomad/gsql/internal/types"
)

{{range .}}
// ==================== {{.Name}} ====================

type {{.Name}}[T any] struct {
	{{.InnerName | camel}}[T]
	flags types.FieldFlag
	column clauses2.ColumnQuote
}

func New{{.Name}}[T any](tableName, name string, flags ...types.FieldFlag) {{.Name}}[T] {
	q := clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := {{.Name}}[T]{
		{{.InnerName | camel}}: {{.InnerExpr | trimSuffix "Expr"}}Of[T](&q),
		column: q,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

// func New{{.Name}}From[T any](f fieldi.IField) {{.Name}}[T] {
// 	base := fieldi.IFieldToBase(f)
// 	expr := base.ToExpr()
// 	return {{.Name}}[T]{
// 		{{.InnerName | camel}}: {{.InnerExpr | trimSuffix "Expr"}}Of[T](expr),
// 	}
// }

/////////////// base ///////////////

func (f {{.Name}}[T]) Build(builder clause.Builder) {
	f.{{.InnerName | camel}}.Build(builder)
}

func (f {{.Name}}[T]) ToExpr() clause.Expression {
	return f.{{.InnerName | camel}}
}

func (f {{.Name}}[T]) Unwrap() clause.Expression {
	return f.{{.InnerName | camel}}
}

func (f {{.Name}}[T]) Expr() {{.InnerName}}[T] {
	return f.{{.InnerName | camel}}
}

func (f {{.Name}}[T]) Wrap(functionName FunctionName) {{.Name}}[T] {
	var expr = f.{{.InnerName | camel}}.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	return {{.Name}}[T] {
		{{.InnerName | camel}}: {{.InnerExpr | trimSuffix "Expr"}}Of[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{expr},
		}),
	}
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f {{.Name}}[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f {{.Name}}[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f {{.Name}}[T]) Name() string {
	return f.column.Name()
}

func (f {{.Name}}[T]) Alias() string {
	return f.column.Alias
}

func (f {{.Name}}[T]) FullName() string {
	return f.column.FullName()
}

func (f {{.Name}}[T]) As(alias string) fieldi.IField {
	var expr = f.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.Alias = alias
	} else {
		// ignore
	}
	return f
}

func (f {{.Name}}[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) {{.Name}}[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return New{{.Name}}[T](tableName.TableName(), name)
}

func (f {{.Name}}[T]) WithAlias(alias string) {{.Name}}[T] {
	cloned := f
	cloned.column.Alias = alias
	return cloned
}

/////////////// flags ///////////////

func (f {{.Name}}[T]) FieldType() T {
	var def T
	return def
}

func (f {{.Name}}[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f {{.Name}}[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f {{.Name}}[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f {{.Name}}[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f {{.Name}}[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f {{.Name}}[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

{{end}}
`

func main() {
	funcMap := template.FuncMap{
		"camel": func(s string) string {
			return s
			//return strings.ToLower(s[0:1]) + s[1:]
		},
		"trimSuffix": func(suffix, s string) string {
			return strings.TrimSuffix(s, suffix)
		},
	}
	t := template.Must(template.New("fields").Funcs(funcMap).Parse(tpl))

	var buf bytes.Buffer
	if err := t.Execute(&buf, fieldTypes); err != nil {
		panic(err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// 如果格式化失败，输出原始内容以便调试
		os.WriteFile("field_gen.go", buf.Bytes(), 0644)
		panic(err)
	}

	if err := os.WriteFile("field_gen.go", formatted, 0644); err != nil {
		panic(err)
	}
}
