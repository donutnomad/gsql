//go:build ignore

//go:generate go run gen.go

package main

import (
	"bytes"
	"go/format"
	"os"
	"strings"
	"text/template"
)

type FieldType struct {
	Name      string // e.g., "IntField"
	InnerExpr string // e.g., "IntExpr"
	InnerName string // e.g., "IntExpr" (field name in struct)
}

var fieldTypes = []FieldType{
	newFieldType("IntExpr"),
	newFieldType("FloatExpr"),
	newFieldType("DecimalExpr"),
	newFieldType("StringExpr"),
	newFieldType("DateTimeExpr"),
	newFieldType("DateExpr"),
	newFieldType("TimeExpr"),
	newFieldType("ScalarExpr"),
}

func newFieldType(input string) FieldType {
	a := strings.TrimSuffix(input, "Expr") + "Field"
	return FieldType{a, input, input}
}

const tpl = `// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/fieldi"
	"github.com/donutnomad/gsql/internal/types"
)

{{range .}}
// ==================== {{.Name}} ====================

type {{.Name}}[T any] struct {
	fieldi.Base
	{{.InnerName}}[T]
}

func New{{.Name}}[T any](tableName, name string, flags ...types.FieldFlag) {{.Name}}[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return New{{.Name}}From[T](b)
}

func New{{.Name}}From[T any](f fieldi.IField) {{.Name}}[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return {{.Name}}[T]{
		Base:      base,
		{{.InnerName}}: {{.InnerExpr | trimSuffix "Expr"}}Of[T](expr),
	}
}

func (f {{.Name}}[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f {{.Name}}[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f {{.Name}}[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f {{.Name}}[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) {{.Name}}[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return New{{.Name}}[T](tableName.TableName(), name)
}

func (f {{.Name}}[T]) WithAlias(alias string) {{.Name}}[T] {
	b := f.Base.SetAlias(alias)
	return New{{.Name}}From[T](b)
}

func (f {{.Name}}[T]) FieldType() T {
	var def T
	return def
}

func (f {{.Name}}[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f {{.Name}}[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}
{{end}}
`

func main() {
	funcMap := template.FuncMap{
		"trimSuffix": func(suffix, s string) string {
			return strings.TrimSuffix(s, suffix)
		},
	}
	t := template.Must(template.New("fields").Funcs(funcMap).Parse(tpl))

	var buf bytes.Buffer
	if err := t.Execute(&buf, fieldTypes); err != nil {
		panic(err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// 如果格式化失败，输出原始内容以便调试
		os.WriteFile("field_gen.go", buf.Bytes(), 0644)
		panic(err)
	}

	if err := os.WriteFile("field_gen.go", formatted, 0644); err != nil {
		panic(err)
	}
}
