// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/clauses2"
	"github.com/donutnomad/gsql/internal/fieldi"
	"github.com/donutnomad/gsql/internal/types"
)

// ==================== IntField ====================

type IntField[T any] struct {
	IntExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func IntFieldOf[T any](tableName, name string, flags ...types.FieldFlag) IntField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := IntField[T]{
		IntExpr: IntOf[T](q),
		column:  q,
		flags:   0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func IntColumn[T any](name string) IntColumnBuilder[T] {
	return IntColumnBuilder[T]{name: name}
}

type IntColumnBuilder[T any] struct {
	name string
}

func (b IntColumnBuilder[T]) From(source interface{ TableName() string }) IntField[T] {
	return IntFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f IntField[T]) Build(builder clause.Builder) {
	f.IntExpr.Build(builder)
}

func (f IntField[T]) ToExpr() clause.Expression {
	return f.IntExpr
}

func (f IntField[T]) Unwrap() clause.Expression {
	return f.IntExpr
}

func (f IntField[T]) Expr() IntExpr[T] {
	return f.IntExpr
}

func (f IntField[T]) Apply(functionName FunctionName) IntExpr[T] {
	var expr = f.IntExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return IntOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f IntField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f IntField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f IntField[T]) Name() string {
	return f.column.Name()
}

func (f IntField[T]) Alias() string {
	return f.column.Alias
}

func (f IntField[T]) FullName() string {
	return f.column.FullName()
}

func (f IntField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f IntField[T]) WithAlias(alias string) IntField[T] {
	ret := IntFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f IntField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) IntField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return IntFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f IntField[T]) FieldType() T {
	var def T
	return def
}

func (f IntField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f IntField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f IntField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f IntField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f IntField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f IntField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== FloatField ====================

type FloatField[T any] struct {
	FloatExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func FloatFieldOf[T any](tableName, name string, flags ...types.FieldFlag) FloatField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := FloatField[T]{
		FloatExpr: FloatOf[T](q),
		column:    q,
		flags:     0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func FloatColumn[T any](name string) FloatColumnBuilder[T] {
	return FloatColumnBuilder[T]{name: name}
}

type FloatColumnBuilder[T any] struct {
	name string
}

func (b FloatColumnBuilder[T]) From(source interface{ TableName() string }) FloatField[T] {
	return FloatFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f FloatField[T]) Build(builder clause.Builder) {
	f.FloatExpr.Build(builder)
}

func (f FloatField[T]) ToExpr() clause.Expression {
	return f.FloatExpr
}

func (f FloatField[T]) Unwrap() clause.Expression {
	return f.FloatExpr
}

func (f FloatField[T]) Expr() FloatExpr[T] {
	return f.FloatExpr
}

func (f FloatField[T]) Apply(functionName FunctionName) FloatExpr[T] {
	var expr = f.FloatExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return FloatOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f FloatField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f FloatField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f FloatField[T]) Name() string {
	return f.column.Name()
}

func (f FloatField[T]) Alias() string {
	return f.column.Alias
}

func (f FloatField[T]) FullName() string {
	return f.column.FullName()
}

func (f FloatField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f FloatField[T]) WithAlias(alias string) FloatField[T] {
	ret := FloatFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f FloatField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) FloatField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return FloatFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f FloatField[T]) FieldType() T {
	var def T
	return def
}

func (f FloatField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f FloatField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f FloatField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f FloatField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f FloatField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f FloatField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DecimalField ====================

type DecimalField[T any] struct {
	DecimalExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func DecimalFieldOf[T any](tableName, name string, flags ...types.FieldFlag) DecimalField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := DecimalField[T]{
		DecimalExpr: DecimalOf[T](q),
		column:      q,
		flags:       0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func DecimalColumn[T any](name string) DecimalColumnBuilder[T] {
	return DecimalColumnBuilder[T]{name: name}
}

type DecimalColumnBuilder[T any] struct {
	name string
}

func (b DecimalColumnBuilder[T]) From(source interface{ TableName() string }) DecimalField[T] {
	return DecimalFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f DecimalField[T]) Build(builder clause.Builder) {
	f.DecimalExpr.Build(builder)
}

func (f DecimalField[T]) ToExpr() clause.Expression {
	return f.DecimalExpr
}

func (f DecimalField[T]) Unwrap() clause.Expression {
	return f.DecimalExpr
}

func (f DecimalField[T]) Expr() DecimalExpr[T] {
	return f.DecimalExpr
}

func (f DecimalField[T]) Apply(functionName FunctionName) DecimalExpr[T] {
	var expr = f.DecimalExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return DecimalOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DecimalField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DecimalField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DecimalField[T]) Name() string {
	return f.column.Name()
}

func (f DecimalField[T]) Alias() string {
	return f.column.Alias
}

func (f DecimalField[T]) FullName() string {
	return f.column.FullName()
}

func (f DecimalField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f DecimalField[T]) WithAlias(alias string) DecimalField[T] {
	ret := DecimalFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f DecimalField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DecimalField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return DecimalFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f DecimalField[T]) FieldType() T {
	var def T
	return def
}

func (f DecimalField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DecimalField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DecimalField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DecimalField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DecimalField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DecimalField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== StringField ====================

type StringField[T any] struct {
	StringExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func StringFieldOf[T any](tableName, name string, flags ...types.FieldFlag) StringField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := StringField[T]{
		StringExpr: StringOf[T](q),
		column:     q,
		flags:      0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func StringColumn[T any](name string) StringColumnBuilder[T] {
	return StringColumnBuilder[T]{name: name}
}

type StringColumnBuilder[T any] struct {
	name string
}

func (b StringColumnBuilder[T]) From(source interface{ TableName() string }) StringField[T] {
	return StringFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f StringField[T]) Build(builder clause.Builder) {
	f.StringExpr.Build(builder)
}

func (f StringField[T]) ToExpr() clause.Expression {
	return f.StringExpr
}

func (f StringField[T]) Unwrap() clause.Expression {
	return f.StringExpr
}

func (f StringField[T]) Expr() StringExpr[T] {
	return f.StringExpr
}

func (f StringField[T]) Apply(functionName FunctionName) StringExpr[T] {
	var expr = f.StringExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return StringOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f StringField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f StringField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f StringField[T]) Name() string {
	return f.column.Name()
}

func (f StringField[T]) Alias() string {
	return f.column.Alias
}

func (f StringField[T]) FullName() string {
	return f.column.FullName()
}

func (f StringField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f StringField[T]) WithAlias(alias string) StringField[T] {
	ret := StringFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f StringField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) StringField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return StringFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f StringField[T]) FieldType() T {
	var def T
	return def
}

func (f StringField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f StringField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f StringField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f StringField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f StringField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f StringField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateTimeField ====================

type DateTimeField[T any] struct {
	DateTimeExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func DateTimeFieldOf[T any](tableName, name string, flags ...types.FieldFlag) DateTimeField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := DateTimeField[T]{
		DateTimeExpr: DateTimeOf[T](q),
		column:       q,
		flags:        0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func DateTimeColumn[T any](name string) DateTimeColumnBuilder[T] {
	return DateTimeColumnBuilder[T]{name: name}
}

type DateTimeColumnBuilder[T any] struct {
	name string
}

func (b DateTimeColumnBuilder[T]) From(source interface{ TableName() string }) DateTimeField[T] {
	return DateTimeFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f DateTimeField[T]) Build(builder clause.Builder) {
	f.DateTimeExpr.Build(builder)
}

func (f DateTimeField[T]) ToExpr() clause.Expression {
	return f.DateTimeExpr
}

func (f DateTimeField[T]) Unwrap() clause.Expression {
	return f.DateTimeExpr
}

func (f DateTimeField[T]) Expr() DateTimeExpr[T] {
	return f.DateTimeExpr
}

func (f DateTimeField[T]) Apply(functionName FunctionName) DateTimeExpr[T] {
	var expr = f.DateTimeExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return DateTimeOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DateTimeField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DateTimeField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DateTimeField[T]) Name() string {
	return f.column.Name()
}

func (f DateTimeField[T]) Alias() string {
	return f.column.Alias
}

func (f DateTimeField[T]) FullName() string {
	return f.column.FullName()
}

func (f DateTimeField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f DateTimeField[T]) WithAlias(alias string) DateTimeField[T] {
	ret := DateTimeFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f DateTimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateTimeField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return DateTimeFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f DateTimeField[T]) FieldType() T {
	var def T
	return def
}

func (f DateTimeField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DateTimeField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DateTimeField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DateTimeField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DateTimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateTimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateField ====================

type DateField[T any] struct {
	DateExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func DateFieldOf[T any](tableName, name string, flags ...types.FieldFlag) DateField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := DateField[T]{
		DateExpr: DateOf[T](q),
		column:   q,
		flags:    0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func DateColumn[T any](name string) DateColumnBuilder[T] {
	return DateColumnBuilder[T]{name: name}
}

type DateColumnBuilder[T any] struct {
	name string
}

func (b DateColumnBuilder[T]) From(source interface{ TableName() string }) DateField[T] {
	return DateFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f DateField[T]) Build(builder clause.Builder) {
	f.DateExpr.Build(builder)
}

func (f DateField[T]) ToExpr() clause.Expression {
	return f.DateExpr
}

func (f DateField[T]) Unwrap() clause.Expression {
	return f.DateExpr
}

func (f DateField[T]) Expr() DateExpr[T] {
	return f.DateExpr
}

func (f DateField[T]) Apply(functionName FunctionName) DateExpr[T] {
	var expr = f.DateExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return DateOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DateField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DateField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DateField[T]) Name() string {
	return f.column.Name()
}

func (f DateField[T]) Alias() string {
	return f.column.Alias
}

func (f DateField[T]) FullName() string {
	return f.column.FullName()
}

func (f DateField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f DateField[T]) WithAlias(alias string) DateField[T] {
	ret := DateFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f DateField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return DateFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f DateField[T]) FieldType() T {
	var def T
	return def
}

func (f DateField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DateField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DateField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DateField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DateField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== TimeField ====================

type TimeField[T any] struct {
	TimeExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func TimeFieldOf[T any](tableName, name string, flags ...types.FieldFlag) TimeField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := TimeField[T]{
		TimeExpr: TimeOf[T](q),
		column:   q,
		flags:    0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func TimeColumn[T any](name string) TimeColumnBuilder[T] {
	return TimeColumnBuilder[T]{name: name}
}

type TimeColumnBuilder[T any] struct {
	name string
}

func (b TimeColumnBuilder[T]) From(source interface{ TableName() string }) TimeField[T] {
	return TimeFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f TimeField[T]) Build(builder clause.Builder) {
	f.TimeExpr.Build(builder)
}

func (f TimeField[T]) ToExpr() clause.Expression {
	return f.TimeExpr
}

func (f TimeField[T]) Unwrap() clause.Expression {
	return f.TimeExpr
}

func (f TimeField[T]) Expr() TimeExpr[T] {
	return f.TimeExpr
}

func (f TimeField[T]) Apply(functionName FunctionName) TimeExpr[T] {
	var expr = f.TimeExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return TimeOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f TimeField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f TimeField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f TimeField[T]) Name() string {
	return f.column.Name()
}

func (f TimeField[T]) Alias() string {
	return f.column.Alias
}

func (f TimeField[T]) FullName() string {
	return f.column.FullName()
}

func (f TimeField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f TimeField[T]) WithAlias(alias string) TimeField[T] {
	ret := TimeFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f TimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TimeField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return TimeFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f TimeField[T]) FieldType() T {
	var def T
	return def
}

func (f TimeField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f TimeField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f TimeField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f TimeField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f TimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== ScalarField ====================

type ScalarField[T any] struct {
	ScalarExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func ScalarFieldOf[T any](tableName, name string, flags ...types.FieldFlag) ScalarField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := ScalarField[T]{
		ScalarExpr: ScalarOf[T](q),
		column:     q,
		flags:      0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func ScalarColumn[T any](name string) ScalarColumnBuilder[T] {
	return ScalarColumnBuilder[T]{name: name}
}

type ScalarColumnBuilder[T any] struct {
	name string
}

func (b ScalarColumnBuilder[T]) From(source interface{ TableName() string }) ScalarField[T] {
	return ScalarFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f ScalarField[T]) Build(builder clause.Builder) {
	f.ScalarExpr.Build(builder)
}

func (f ScalarField[T]) ToExpr() clause.Expression {
	return f.ScalarExpr
}

func (f ScalarField[T]) Unwrap() clause.Expression {
	return f.ScalarExpr
}

func (f ScalarField[T]) Expr() ScalarExpr[T] {
	return f.ScalarExpr
}

func (f ScalarField[T]) Apply(functionName FunctionName) ScalarExpr[T] {
	var expr = f.ScalarExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return ScalarOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f ScalarField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f ScalarField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f ScalarField[T]) Name() string {
	return f.column.Name()
}

func (f ScalarField[T]) Alias() string {
	return f.column.Alias
}

func (f ScalarField[T]) FullName() string {
	return f.column.FullName()
}

func (f ScalarField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f ScalarField[T]) WithAlias(alias string) ScalarField[T] {
	ret := ScalarFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f ScalarField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) ScalarField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return ScalarFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f ScalarField[T]) FieldType() T {
	var def T
	return def
}

func (f ScalarField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f ScalarField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f ScalarField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f ScalarField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f ScalarField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f ScalarField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}
