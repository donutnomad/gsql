// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/clauses2"
	"github.com/donutnomad/gsql/internal/fieldi"
	"github.com/donutnomad/gsql/internal/types"
	"github.com/samber/mo"
)

// ==================== IntField ====================

type IntField[T any] struct {
	expr   IntExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func IntFieldOf[T any](tableName, name string, flags ...types.FieldFlag) IntField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := IntField[T]{
		expr:   IntOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func IntColumn[T any](name string) IntColumnBuilder[T] {
	return IntColumnBuilder[T]{name: name}
}

type IntColumnBuilder[T any] struct {
	name string
}

func (b IntColumnBuilder[T]) From(source interface{ TableName() string }) IntField[T] {
	return IntFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f IntField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f IntField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f IntField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f IntField[T]) Expr() IntExpr[T] {
	return f.expr
}

func (f IntField[T]) Apply(functionName FunctionName) IntExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return IntOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f IntField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f IntField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f IntField[T]) Name() string {
	return f.column.Name()
}

func (f IntField[T]) Alias() string {
	return f.column.Alias
}

func (f IntField[T]) FullName() string {
	return f.column.FullName()
}

func (f IntField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f IntField[T]) WithAlias(alias string) IntField[T] {
	ret := IntFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f IntField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) IntField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return IntFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f IntField[T]) FieldType() T {
	var def T
	return def
}

func (f IntField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f IntField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f IntField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f IntField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f IntField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f IntField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from IntExpr ///////////////

// AsFloat 转换为 FloatExpr（不生成 SQL，仅类型转换）
func (f IntField[T]) AsFloat() FloatExpr[float64] {
	return f.expr.AsFloat()
}

// AsDecimal 转换为 DecimalExpr（不生成 SQL，仅类型转换）
func (f IntField[T]) AsDecimal() DecimalExpr[float64] {
	return f.expr.AsDecimal()
}

// Cast 类型转换 (CAST)
func (f IntField[T]) Cast(targetType string) clause.Expression {
	return f.expr.Cast(targetType)
}

// CastFloat 转换为浮点数 (CAST AS DECIMAL)
func (f IntField[T]) CastFloat(precision int, scale int) FloatExpr[float64] {
	return f.expr.CastFloat(precision, scale)
}

// CastChar 转换为字符串 (CAST AS CHAR)
func (f IntField[T]) CastChar(length ...int) StringExpr[string] {
	return f.expr.CastChar(length...)
}

// CastSigned 转换为有符号整数 (CAST AS SIGNED)
func (f IntField[T]) CastSigned() IntExpr[int64] {
	return f.expr.CastSigned()
}

// CastUnsigned 转换为无符号整数 (CAST AS UNSIGNED)
func (f IntField[T]) CastUnsigned() IntExpr[uint64] {
	return f.expr.CastUnsigned()
}

// Hex 转换为十六进制字符串 (HEX)
func (f IntField[T]) Hex() StringExpr[string] {
	return f.expr.Hex()
}

// Bin 转换为二进制字符串 (BIN)
func (f IntField[T]) Bin() StringExpr[string] {
	return f.expr.Bin()
}

// Oct 转换为八进制字符串 (OCT)
func (f IntField[T]) Oct() StringExpr[string] {
	return f.expr.Oct()
}

// InetNtoa 将整数形式的IP地址转换为点分十进制字符串 (INET_NTOA)
// SELECT INET_NTOA(3232235777); -- 结果为 '192.168.1.1'
// SELECT INET_NTOA(ip_address) FROM access_logs;
func (f IntField[T]) InetNtoa() StringExpr[string] {
	return f.expr.InetNtoa()
}

// SecToTime 将秒数转换为时间 (SEC_TO_TIME)
// 数据库支持: MySQL
// SELECT SEC_TO_TIME(5400); -- 返回 '01:30:00'
func (f IntField[T]) SecToTime() TimeExpr[string] {
	return f.expr.SecToTime()
}

// FromDays 将天数转换为日期 (FROM_DAYS)
// 数据库支持: MySQL
// SELECT FROM_DAYS(739259); -- 返回 '2024-01-15'
func (f IntField[T]) FromDays() DateExpr[string] {
	return f.expr.FromDays()
}

// ToDateTime 将 Unix 时间戳转换为 DATETIME 类型 (FROM_UNIXTIME)
// 数据库支持: MySQL
// SELECT FROM_UNIXTIME(1698306600); -- 返回 '2023-10-26 10:30:00'
// SELECT FROM_UNIXTIME(created_at) FROM users;
// 可链式调用日期时间方法，如 .YearExpr(), .Format() 等
func (f IntField[T]) ToDateTime() DateTimeExpr[string] {
	return f.expr.ToDateTime()
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f IntField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f IntField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// Add 加法 (+)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price + 100 FROM products;
// SELECT users.age + 1 FROM users;
func (f IntField[T]) Add(value any) IntExpr[T] {
	return f.expr.Add(value)
}

// Sub 减法 (-)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price - discount FROM products;
// SELECT stock - sold FROM inventory;
func (f IntField[T]) Sub(value any) IntExpr[T] {
	return f.expr.Sub(value)
}

// Mul 乘法 (*)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price * quantity FROM order_items;
// SELECT users.level * 10 as points FROM users;
func (f IntField[T]) Mul(value any) IntExpr[T] {
	return f.expr.Mul(value)
}

// Div 除法 (/)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT total / count FROM stats;
// SELECT points / 100 as level FROM users;
func (f IntField[T]) Div(value any) FloatExpr[float64] {
	return f.expr.Div(value)
}

// Neg 取负 (-)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT -price FROM products;
func (f IntField[T]) Neg() IntExpr[T] {
	return f.expr.Neg()
}

// Mod 取模 (MOD)
// 数据库支持: MySQL (PostgreSQL/SQLite 使用 % 操作符)
// SELECT MOD(10, 3); -- 结果为 1
// SELECT MOD(234, 10); -- 结果为 4
// SELECT * FROM users WHERE MOD(id, 2) = 0; -- 偶数ID
func (f IntField[T]) Mod(value any) IntExpr[T] {
	return f.expr.Mod(value)
}

// Abs 返回绝对值 (ABS)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ABS(-10); -- 结果为 10
// SELECT ABS(price - cost) FROM products;
func (f IntField[T]) Abs() IntExpr[T] {
	return f.expr.Abs()
}

// Sign 返回符号 (SIGN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SIGN(-10); -- 结果为 -1
// SELECT SIGN(0); -- 结果为 0
// SELECT SIGN(10); -- 结果为 1
func (f IntField[T]) Sign() IntExpr[int8] {
	return f.expr.Sign()
}

// Ceil 向上取整 (CEIL)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT CEIL(1.5); -- 结果为 2
// SELECT CEIL(-1.5); -- 结果为 -1
func (f IntField[T]) Ceil() IntExpr[T] {
	return f.expr.Ceil()
}

// Floor 向下取整 (FLOOR)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT FLOOR(1.5); -- 结果为 1
// SELECT FLOOR(-1.5); -- 结果为 -2
func (f IntField[T]) Floor() IntExpr[T] {
	return f.expr.Floor()
}

// Pow 幂运算 (POW)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT POW(2, 3); -- 结果为 8
// SELECT POW(price, 2) FROM products;
func (f IntField[T]) Pow(exponent float64) FloatExpr[float64] {
	return f.expr.Pow(exponent)
}

// Sqrt 平方根 (SQRT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SQRT(16); -- 结果为 4
// SELECT SQRT(variance) FROM stats;
func (f IntField[T]) Sqrt() FloatExpr[float64] {
	return f.expr.Sqrt()
}

// Log 自然对数 (LOG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT LOG(10); -- 结果为 2.302585...
func (f IntField[T]) Log() FloatExpr[float64] {
	return f.expr.Log()
}

// Log10 以10为底的对数 (LOG10)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT LOG10(100); -- 结果为 2
func (f IntField[T]) Log10() FloatExpr[float64] {
	return f.expr.Log10()
}

// Log2 以2为底的对数 (LOG2)
// 数据库支持: MySQL (PostgreSQL/SQLite 不直接支持)
// SELECT LOG2(8); -- 结果为 3
func (f IntField[T]) Log2() FloatExpr[float64] {
	return f.expr.Log2()
}

// Exp 指数函数 (EXP)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT EXP(1); -- 结果为 2.718281828...
func (f IntField[T]) Exp() FloatExpr[float64] {
	return f.expr.Exp()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f IntField[T]) IfNull(defaultValue any) IntExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f IntField[T]) Coalesce(values ...any) IntExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f IntField[T]) NullIf(value any) IntExpr[T] {
	return f.expr.NullIf(value)
}

// Greatest 返回参数列表中的最大值 (GREATEST)
// 数据库支持: MySQL, PostgreSQL (SQLite 不支持)
// SELECT GREATEST(10, 20, 30); -- 返回 30
// SELECT GREATEST(price, min_price) FROM products;
func (f IntField[T]) Greatest(values ...any) IntExpr[T] {
	return f.expr.Greatest(values...)
}

// Least 返回参数列表中的最小值 (LEAST)
// 数据库支持: MySQL, PostgreSQL (SQLite 不支持)
// SELECT LEAST(10, 20, 30); -- 返回 10
// SELECT LEAST(price, max_price) FROM products;
func (f IntField[T]) Least(values ...any) IntExpr[T] {
	return f.expr.Least(values...)
}

// BitAnd 按位与 (&)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT 5 & 3; -- 结果为 1
// SELECT flags & 0x0F FROM settings;
func (f IntField[T]) BitAnd(value any) IntExpr[T] {
	return f.expr.BitAnd(value)
}

// BitOr 按位或 (|)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT 5 | 3; -- 结果为 7
// SELECT flags | 0x10 FROM settings;
func (f IntField[T]) BitOr(value any) IntExpr[T] {
	return f.expr.BitOr(value)
}

// BitXor 按位异或 (^)
// 数据库支持: MySQL, PostgreSQL (使用 #), SQLite
// SELECT 5 ^ 3; -- 结果为 6
// SELECT flags ^ mask FROM settings;
func (f IntField[T]) BitXor(value any) IntExpr[T] {
	return f.expr.BitXor(value)
}

// BitNot 按位取反 (~)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ~5; -- 结果为 -6 (有符号整数)
// SELECT ~flags FROM settings;
func (f IntField[T]) BitNot() IntExpr[T] {
	return f.expr.BitNot()
}

// LeftShift 左移 (<<)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT 1 << 4; -- 结果为 16
// SELECT value << 2 FROM data;
func (f IntField[T]) LeftShift(n int) IntExpr[T] {
	return f.expr.LeftShift(n)
}

// RightShift 右移 (>>)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT 16 >> 2; -- 结果为 4
// SELECT value >> 1 FROM data;
func (f IntField[T]) RightShift(n int) IntExpr[T] {
	return f.expr.RightShift(n)
}

// IntDiv 整数除法 (DIV)
// 数据库支持: MySQL (PostgreSQL/SQLite 使用 / 或 TRUNC)
// SELECT 10 DIV 3; -- 结果为 3
// SELECT total DIV page_size as pages FROM posts;
func (f IntField[T]) IntDiv(value any) IntExpr[T] {
	return f.expr.IntDiv(value)
}

// Sum 计算数值的总和 (SUM)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SUM(quantity) FROM orders;
// SELECT user_id, SUM(points) FROM transactions GROUP BY user_id;
func (f IntField[T]) Sum() DecimalExpr[T] {
	return f.expr.Sum()
}

// Avg 计算数值的平均值 (AVG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT AVG(score) FROM students;
// SELECT class_id, AVG(grade) FROM exams GROUP BY class_id;
func (f IntField[T]) Avg() FloatExpr[float64] {
	return f.expr.Avg()
}

// Max 返回最大值 (MAX)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MAX(price) FROM products;
// SELECT category, MAX(stock) FROM inventory GROUP BY category;
func (f IntField[T]) Max() IntExpr[T] {
	return f.expr.Max()
}

// Min 返回最小值 (MIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MIN(price) FROM products;
// SELECT category, MIN(stock) FROM inventory GROUP BY category;
func (f IntField[T]) Min() IntExpr[T] {
	return f.expr.Min()
}

func (f IntField[T]) Gt(value T) Condition {
	return f.expr.Gt(value)
}

func (f IntField[T]) GtOpt(value mo.Option[T]) Condition {
	return f.expr.GtOpt(value)
}

func (f IntField[T]) GtF(other clause.Expression) Condition {
	return f.expr.GtF(other)
}

func (f IntField[T]) Gte(value T) Condition {
	return f.expr.Gte(value)
}

func (f IntField[T]) GteOpt(value mo.Option[T]) Condition {
	return f.expr.GteOpt(value)
}

func (f IntField[T]) GteF(other clause.Expression) Condition {
	return f.expr.GteF(other)
}

func (f IntField[T]) Lt(value T) Condition {
	return f.expr.Lt(value)
}

func (f IntField[T]) LtOpt(value mo.Option[T]) Condition {
	return f.expr.LtOpt(value)
}

func (f IntField[T]) LtF(other clause.Expression) Condition {
	return f.expr.LtF(other)
}

func (f IntField[T]) Lte(value T) Condition {
	return f.expr.Lte(value)
}

func (f IntField[T]) LteOpt(value mo.Option[T]) Condition {
	return f.expr.LteOpt(value)
}

func (f IntField[T]) LteF(other clause.Expression) Condition {
	return f.expr.LteF(other)
}

// Between 范围查询（使用组合条件而非 SQL BETWEEN 语法）
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
// 默认形成左闭右开区间: from <= field < to
// 示例: field.Between(1, 10) => field >= 1 AND field < 10
// 示例: field.Between(1, 10, ">", "<=") => field > 1 AND field <= 10
func (f IntField[T]) Between(from *T, to *T, op ...string) Condition {
	return f.expr.Between(from, to, op...)
}

// NotBetween 范围排除查询（使用 OR 组合条件）
// opFrom: >=, >, =, <=, < 默认: <（NotBetween 的 from 条件是小于）
// opTo: >=, >, =, <=, < 默认: >=（NotBetween 的 to 条件是大于等于）
// 默认: field < from OR field >= to
// 示例: field.NotBetween(1, 10) => field < 1 OR field >= 10
func (f IntField[T]) NotBetween(from *T, to *T, op ...string) Condition {
	return f.expr.NotBetween(from, to, op...)
}

// BetweenRange 使用 Range 参数的范围查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f IntField[T]) BetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.BetweenRange(rng, op...)
}

// BetweenOpt 使用 Option 参数的范围查询
func (f IntField[T]) BetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.BetweenOpt(from, to, op...)
}

// BetweenF 使用字段参数的范围查询
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f IntField[T]) BetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.BetweenF(from, to, op...)
}

// NotBetweenRange 使用 Range 参数的范围排除查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
// 示例: field < from OR field >= to
func (f IntField[T]) NotBetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.NotBetweenRange(rng, op...)
}

// NotBetweenOpt 使用 Option 参数的范围排除查询
func (f IntField[T]) NotBetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.NotBetweenOpt(from, to, op...)
}

// NotBetweenF 使用字段参数的范围排除查询
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
func (f IntField[T]) NotBetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.NotBetweenF(from, to, op...)
}

func (f IntField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f IntField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f IntField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f IntField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f IntField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f IntField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f IntField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f IntField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f IntField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f IntField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f IntField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f IntField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== FloatField ====================

type FloatField[T any] struct {
	expr   FloatExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func FloatFieldOf[T any](tableName, name string, flags ...types.FieldFlag) FloatField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := FloatField[T]{
		expr:   FloatOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func FloatColumn[T any](name string) FloatColumnBuilder[T] {
	return FloatColumnBuilder[T]{name: name}
}

type FloatColumnBuilder[T any] struct {
	name string
}

func (b FloatColumnBuilder[T]) From(source interface{ TableName() string }) FloatField[T] {
	return FloatFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f FloatField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f FloatField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f FloatField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f FloatField[T]) Expr() FloatExpr[T] {
	return f.expr
}

func (f FloatField[T]) Apply(functionName FunctionName) FloatExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return FloatOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f FloatField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f FloatField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f FloatField[T]) Name() string {
	return f.column.Name()
}

func (f FloatField[T]) Alias() string {
	return f.column.Alias
}

func (f FloatField[T]) FullName() string {
	return f.column.FullName()
}

func (f FloatField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f FloatField[T]) WithAlias(alias string) FloatField[T] {
	ret := FloatFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f FloatField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) FloatField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return FloatFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f FloatField[T]) FieldType() T {
	var def T
	return def
}

func (f FloatField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f FloatField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f FloatField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f FloatField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f FloatField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f FloatField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from FloatExpr ///////////////

// Cast 类型转换 (CAST)
func (f FloatField[T]) Cast(targetType string) clause.Expression {
	return f.expr.Cast(targetType)
}

// CastSigned 转换为有符号整数 (CAST AS SIGNED)
func (f FloatField[T]) CastSigned() IntExpr[int64] {
	return f.expr.CastSigned()
}

// CastUnsigned 转换为无符号整数 (CAST AS UNSIGNED)
func (f FloatField[T]) CastUnsigned() IntExpr[uint64] {
	return f.expr.CastUnsigned()
}

// CastDecimal 转换为指定精度的小数 (CAST AS DECIMAL)
func (f FloatField[T]) CastDecimal(precision int, scale int) DecimalExpr[float64] {
	return f.expr.CastDecimal(precision, scale)
}

// CastChar 转换为字符串 (CAST AS CHAR)
func (f FloatField[T]) CastChar(length ...int) StringExpr[string] {
	return f.expr.CastChar(length...)
}

// Format 格式化数字 (FORMAT)
func (f FloatField[T]) Format(decimals int) StringExpr[string] {
	return f.expr.Format(decimals)
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f FloatField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f FloatField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// Add 加法 (+)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price + 100 FROM products;
// SELECT users.age + 1 FROM users;
func (f FloatField[T]) Add(value any) FloatExpr[T] {
	return f.expr.Add(value)
}

// Sub 减法 (-)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price - discount FROM products;
// SELECT stock - sold FROM inventory;
func (f FloatField[T]) Sub(value any) FloatExpr[T] {
	return f.expr.Sub(value)
}

// Mul 乘法 (*)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price * quantity FROM order_items;
// SELECT users.level * 10 as points FROM users;
func (f FloatField[T]) Mul(value any) FloatExpr[T] {
	return f.expr.Mul(value)
}

// Div 除法 (/)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT total / count FROM stats;
// SELECT points / 100 as level FROM users;
func (f FloatField[T]) Div(value any) FloatExpr[T] {
	return f.expr.Div(value)
}

// Neg 取负 (-)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT -price FROM products;
func (f FloatField[T]) Neg() FloatExpr[T] {
	return f.expr.Neg()
}

// Mod 取模 (MOD)
// 数据库支持: MySQL (PostgreSQL/SQLite 使用 % 操作符)
// SELECT MOD(10, 3); -- 结果为 1
// SELECT MOD(234, 10); -- 结果为 4
// SELECT * FROM users WHERE MOD(id, 2) = 0; -- 偶数ID
func (f FloatField[T]) Mod(value any) FloatExpr[T] {
	return f.expr.Mod(value)
}

// Abs 返回绝对值 (ABS)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ABS(-10); -- 结果为 10
// SELECT ABS(price - cost) FROM products;
func (f FloatField[T]) Abs() FloatExpr[T] {
	return f.expr.Abs()
}

// Sign 返回符号 (SIGN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SIGN(-10); -- 结果为 -1
// SELECT SIGN(0); -- 结果为 0
// SELECT SIGN(10); -- 结果为 1
func (f FloatField[T]) Sign() IntExpr[int8] {
	return f.expr.Sign()
}

// Ceil 向上取整 (CEIL)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT CEIL(1.5); -- 结果为 2
// SELECT CEIL(-1.5); -- 结果为 -1
func (f FloatField[T]) Ceil() IntExpr[int64] {
	return f.expr.Ceil()
}

// Floor 向下取整 (FLOOR)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT FLOOR(1.5); -- 结果为 1
// SELECT FLOOR(-1.5); -- 结果为 -2
func (f FloatField[T]) Floor() IntExpr[int64] {
	return f.expr.Floor()
}

// Round 四舍五入 (ROUND)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ROUND(1.567); -- 结果为 2
// SELECT ROUND(1.567, 2); -- 结果为 1.57
func (f FloatField[T]) Round(decimals ...int) FloatExpr[T] {
	return f.expr.Round(decimals...)
}

// Truncate 截断小数 (TRUNCATE)
// 数据库支持: MySQL (PostgreSQL 使用 TRUNC, SQLite 不支持)
// SELECT TRUNCATE(1.567, 2); -- 结果为 1.56
// SELECT TRUNCATE(1.567, 0); -- 结果为 1
func (f FloatField[T]) Truncate(decimals int) FloatExpr[T] {
	return f.expr.Truncate(decimals)
}

// Pow 幂运算 (POW)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT POW(2, 3); -- 结果为 8
// SELECT POW(price, 2) FROM products;
func (f FloatField[T]) Pow(exponent float64) FloatExpr[T] {
	return f.expr.Pow(exponent)
}

// Sqrt 平方根 (SQRT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SQRT(16); -- 结果为 4
// SELECT SQRT(variance) FROM stats;
func (f FloatField[T]) Sqrt() FloatExpr[T] {
	return f.expr.Sqrt()
}

// Log 自然对数 (LOG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT LOG(10); -- 结果为 2.302585...
func (f FloatField[T]) Log() FloatExpr[T] {
	return f.expr.Log()
}

// Log10 以10为底的对数 (LOG10)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT LOG10(100); -- 结果为 2
func (f FloatField[T]) Log10() FloatExpr[T] {
	return f.expr.Log10()
}

// Log2 以2为底的对数 (LOG2)
// 数据库支持: MySQL (PostgreSQL/SQLite 不直接支持)
// SELECT LOG2(8); -- 结果为 3
func (f FloatField[T]) Log2() FloatExpr[T] {
	return f.expr.Log2()
}

// Exp 指数函数 (EXP)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT EXP(1); -- 结果为 2.718281828...
func (f FloatField[T]) Exp() FloatExpr[T] {
	return f.expr.Exp()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f FloatField[T]) IfNull(defaultValue any) FloatExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f FloatField[T]) Coalesce(values ...any) FloatExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f FloatField[T]) NullIf(value any) FloatExpr[T] {
	return f.expr.NullIf(value)
}

// Greatest 返回参数列表中的最大值 (GREATEST)
// 数据库支持: MySQL, PostgreSQL (SQLite 不支持)
// SELECT GREATEST(10, 20, 30); -- 返回 30
// SELECT GREATEST(price, min_price) FROM products;
func (f FloatField[T]) Greatest(values ...any) FloatExpr[T] {
	return f.expr.Greatest(values...)
}

// Least 返回参数列表中的最小值 (LEAST)
// 数据库支持: MySQL, PostgreSQL (SQLite 不支持)
// SELECT LEAST(10, 20, 30); -- 返回 10
// SELECT LEAST(price, max_price) FROM products;
func (f FloatField[T]) Least(values ...any) FloatExpr[T] {
	return f.expr.Least(values...)
}

// Sin 正弦 (SIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SIN(0); -- 结果为 0
// SELECT SIN(PI()/2); -- 结果为 1
func (f FloatField[T]) Sin() FloatExpr[T] {
	return f.expr.Sin()
}

// Cos 余弦 (COS)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COS(0); -- 结果为 1
// SELECT COS(PI()); -- 结果为 -1
func (f FloatField[T]) Cos() FloatExpr[T] {
	return f.expr.Cos()
}

// Tan 正切 (TAN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT TAN(0); -- 结果为 0
// SELECT TAN(PI()/4); -- 结果约为 1
func (f FloatField[T]) Tan() FloatExpr[T] {
	return f.expr.Tan()
}

// Asin 反正弦 (ASIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ASIN(0); -- 结果为 0
// SELECT ASIN(1); -- 结果为 PI()/2
func (f FloatField[T]) Asin() FloatExpr[T] {
	return f.expr.Asin()
}

// Acos 反余弦 (ACOS)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ACOS(1); -- 结果为 0
// SELECT ACOS(0); -- 结果为 PI()/2
func (f FloatField[T]) Acos() FloatExpr[T] {
	return f.expr.Acos()
}

// Atan 反正切 (ATAN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ATAN(0); -- 结果为 0
// SELECT ATAN(1); -- 结果为 PI()/4
func (f FloatField[T]) Atan() FloatExpr[T] {
	return f.expr.Atan()
}

// Radians 角度转弧度 (RADIANS)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT RADIANS(180); -- 结果为 PI()
// SELECT RADIANS(90); -- 结果为 PI()/2
func (f FloatField[T]) Radians() FloatExpr[T] {
	return f.expr.Radians()
}

// Degrees 弧度转角度 (DEGREES)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT DEGREES(PI()); -- 结果为 180
// SELECT DEGREES(PI()/2); -- 结果为 90
func (f FloatField[T]) Degrees() FloatExpr[T] {
	return f.expr.Degrees()
}

// Sum 计算数值的总和 (SUM)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SUM(quantity) FROM orders;
// SELECT user_id, SUM(points) FROM transactions GROUP BY user_id;
func (f FloatField[T]) Sum() FloatExpr[T] {
	return f.expr.Sum()
}

// Avg 计算数值的平均值 (AVG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT AVG(score) FROM students;
// SELECT class_id, AVG(grade) FROM exams GROUP BY class_id;
func (f FloatField[T]) Avg() FloatExpr[float64] {
	return f.expr.Avg()
}

// Max 返回最大值 (MAX)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MAX(price) FROM products;
// SELECT category, MAX(stock) FROM inventory GROUP BY category;
func (f FloatField[T]) Max() FloatExpr[T] {
	return f.expr.Max()
}

// Min 返回最小值 (MIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MIN(price) FROM products;
// SELECT category, MIN(stock) FROM inventory GROUP BY category;
func (f FloatField[T]) Min() FloatExpr[T] {
	return f.expr.Min()
}

func (f FloatField[T]) Gt(value T) Condition {
	return f.expr.Gt(value)
}

func (f FloatField[T]) GtOpt(value mo.Option[T]) Condition {
	return f.expr.GtOpt(value)
}

func (f FloatField[T]) GtF(other clause.Expression) Condition {
	return f.expr.GtF(other)
}

func (f FloatField[T]) Gte(value T) Condition {
	return f.expr.Gte(value)
}

func (f FloatField[T]) GteOpt(value mo.Option[T]) Condition {
	return f.expr.GteOpt(value)
}

func (f FloatField[T]) GteF(other clause.Expression) Condition {
	return f.expr.GteF(other)
}

func (f FloatField[T]) Lt(value T) Condition {
	return f.expr.Lt(value)
}

func (f FloatField[T]) LtOpt(value mo.Option[T]) Condition {
	return f.expr.LtOpt(value)
}

func (f FloatField[T]) LtF(other clause.Expression) Condition {
	return f.expr.LtF(other)
}

func (f FloatField[T]) Lte(value T) Condition {
	return f.expr.Lte(value)
}

func (f FloatField[T]) LteOpt(value mo.Option[T]) Condition {
	return f.expr.LteOpt(value)
}

func (f FloatField[T]) LteF(other clause.Expression) Condition {
	return f.expr.LteF(other)
}

// Between 范围查询（使用组合条件而非 SQL BETWEEN 语法）
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
// 默认形成左闭右开区间: from <= field < to
// 示例: field.Between(1, 10) => field >= 1 AND field < 10
// 示例: field.Between(1, 10, ">", "<=") => field > 1 AND field <= 10
func (f FloatField[T]) Between(from *T, to *T, op ...string) Condition {
	return f.expr.Between(from, to, op...)
}

// NotBetween 范围排除查询（使用 OR 组合条件）
// opFrom: >=, >, =, <=, < 默认: <（NotBetween 的 from 条件是小于）
// opTo: >=, >, =, <=, < 默认: >=（NotBetween 的 to 条件是大于等于）
// 默认: field < from OR field >= to
// 示例: field.NotBetween(1, 10) => field < 1 OR field >= 10
func (f FloatField[T]) NotBetween(from *T, to *T, op ...string) Condition {
	return f.expr.NotBetween(from, to, op...)
}

// BetweenRange 使用 Range 参数的范围查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f FloatField[T]) BetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.BetweenRange(rng, op...)
}

// BetweenOpt 使用 Option 参数的范围查询
func (f FloatField[T]) BetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.BetweenOpt(from, to, op...)
}

// BetweenF 使用字段参数的范围查询
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f FloatField[T]) BetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.BetweenF(from, to, op...)
}

// NotBetweenRange 使用 Range 参数的范围排除查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
// 示例: field < from OR field >= to
func (f FloatField[T]) NotBetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.NotBetweenRange(rng, op...)
}

// NotBetweenOpt 使用 Option 参数的范围排除查询
func (f FloatField[T]) NotBetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.NotBetweenOpt(from, to, op...)
}

// NotBetweenF 使用字段参数的范围排除查询
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
func (f FloatField[T]) NotBetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.NotBetweenF(from, to, op...)
}

func (f FloatField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f FloatField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f FloatField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f FloatField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f FloatField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f FloatField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f FloatField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f FloatField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f FloatField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f FloatField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f FloatField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f FloatField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== DecimalField ====================

type DecimalField[T any] struct {
	expr   DecimalExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func DecimalFieldOf[T any](tableName, name string, flags ...types.FieldFlag) DecimalField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := DecimalField[T]{
		expr:   DecimalOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func DecimalColumn[T any](name string) DecimalColumnBuilder[T] {
	return DecimalColumnBuilder[T]{name: name}
}

type DecimalColumnBuilder[T any] struct {
	name string
}

func (b DecimalColumnBuilder[T]) From(source interface{ TableName() string }) DecimalField[T] {
	return DecimalFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f DecimalField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f DecimalField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f DecimalField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f DecimalField[T]) Expr() DecimalExpr[T] {
	return f.expr
}

func (f DecimalField[T]) Apply(functionName FunctionName) DecimalExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return DecimalOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DecimalField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DecimalField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DecimalField[T]) Name() string {
	return f.column.Name()
}

func (f DecimalField[T]) Alias() string {
	return f.column.Alias
}

func (f DecimalField[T]) FullName() string {
	return f.column.FullName()
}

func (f DecimalField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f DecimalField[T]) WithAlias(alias string) DecimalField[T] {
	ret := DecimalFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f DecimalField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DecimalField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return DecimalFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f DecimalField[T]) FieldType() T {
	var def T
	return def
}

func (f DecimalField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DecimalField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DecimalField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DecimalField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DecimalField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DecimalField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from DecimalExpr ///////////////

// Cast 类型转换 (CAST)
func (f DecimalField[T]) Cast(targetType string) clause.Expression {
	return f.expr.Cast(targetType)
}

// CastSigned 转换为有符号整数 (CAST AS SIGNED)
func (f DecimalField[T]) CastSigned() IntExpr[int64] {
	return f.expr.CastSigned()
}

// CastUnsigned 转换为无符号整数 (CAST AS UNSIGNED)
func (f DecimalField[T]) CastUnsigned() IntExpr[uint64] {
	return f.expr.CastUnsigned()
}

// CastDecimal 转换为指定精度的 DECIMAL (CAST AS DECIMAL)
func (f DecimalField[T]) CastDecimal(precision int, scale int) DecimalExpr[T] {
	return f.expr.CastDecimal(precision, scale)
}

// CastFloat 转换为浮点数 (CAST AS DOUBLE)
func (f DecimalField[T]) CastFloat() FloatExpr[float64] {
	return f.expr.CastFloat()
}

// CastChar 转换为字符串 (CAST AS CHAR)
func (f DecimalField[T]) CastChar(length ...int) StringExpr[string] {
	return f.expr.CastChar(length...)
}

// Format 格式化数字 (FORMAT)
func (f DecimalField[T]) Format(decimals int) StringExpr[string] {
	return f.expr.Format(decimals)
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f DecimalField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f DecimalField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// Add 加法 (+)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price + 100 FROM products;
// SELECT users.age + 1 FROM users;
func (f DecimalField[T]) Add(value any) DecimalExpr[T] {
	return f.expr.Add(value)
}

// Sub 减法 (-)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price - discount FROM products;
// SELECT stock - sold FROM inventory;
func (f DecimalField[T]) Sub(value any) DecimalExpr[T] {
	return f.expr.Sub(value)
}

// Mul 乘法 (*)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT price * quantity FROM order_items;
// SELECT users.level * 10 as points FROM users;
func (f DecimalField[T]) Mul(value any) DecimalExpr[T] {
	return f.expr.Mul(value)
}

// Div 除法 (/)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT total / count FROM stats;
// SELECT points / 100 as level FROM users;
func (f DecimalField[T]) Div(value any) DecimalExpr[T] {
	return f.expr.Div(value)
}

// Neg 取负 (-)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT -price FROM products;
func (f DecimalField[T]) Neg() DecimalExpr[T] {
	return f.expr.Neg()
}

// Mod 取模 (MOD)
// 数据库支持: MySQL (PostgreSQL/SQLite 使用 % 操作符)
// SELECT MOD(10, 3); -- 结果为 1
// SELECT MOD(234, 10); -- 结果为 4
// SELECT * FROM users WHERE MOD(id, 2) = 0; -- 偶数ID
func (f DecimalField[T]) Mod(value any) DecimalExpr[T] {
	return f.expr.Mod(value)
}

// Abs 返回绝对值 (ABS)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ABS(-10); -- 结果为 10
// SELECT ABS(price - cost) FROM products;
func (f DecimalField[T]) Abs() DecimalExpr[T] {
	return f.expr.Abs()
}

// Sign 返回符号 (SIGN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SIGN(-10); -- 结果为 -1
// SELECT SIGN(0); -- 结果为 0
// SELECT SIGN(10); -- 结果为 1
func (f DecimalField[T]) Sign() IntExpr[int8] {
	return f.expr.Sign()
}

// Ceil 向上取整 (CEIL)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT CEIL(1.5); -- 结果为 2
// SELECT CEIL(-1.5); -- 结果为 -1
func (f DecimalField[T]) Ceil() IntExpr[int64] {
	return f.expr.Ceil()
}

// Floor 向下取整 (FLOOR)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT FLOOR(1.5); -- 结果为 1
// SELECT FLOOR(-1.5); -- 结果为 -2
func (f DecimalField[T]) Floor() IntExpr[int64] {
	return f.expr.Floor()
}

// Round 四舍五入 (ROUND)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT ROUND(1.567); -- 结果为 2
// SELECT ROUND(1.567, 2); -- 结果为 1.57
func (f DecimalField[T]) Round(decimals ...int) DecimalExpr[T] {
	return f.expr.Round(decimals...)
}

// Truncate 截断小数 (TRUNCATE)
// 数据库支持: MySQL (PostgreSQL 使用 TRUNC, SQLite 不支持)
// SELECT TRUNCATE(1.567, 2); -- 结果为 1.56
// SELECT TRUNCATE(1.567, 0); -- 结果为 1
func (f DecimalField[T]) Truncate(decimals int) DecimalExpr[T] {
	return f.expr.Truncate(decimals)
}

// Pow 幂运算 (POW)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT POW(2, 3); -- 结果为 8
// SELECT POW(price, 2) FROM products;
func (f DecimalField[T]) Pow(exponent float64) FloatExpr[float64] {
	return f.expr.Pow(exponent)
}

// Sqrt 平方根 (SQRT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SQRT(16); -- 结果为 4
// SELECT SQRT(variance) FROM stats;
func (f DecimalField[T]) Sqrt() FloatExpr[float64] {
	return f.expr.Sqrt()
}

// Log 自然对数 (LOG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT LOG(10); -- 结果为 2.302585...
func (f DecimalField[T]) Log() FloatExpr[float64] {
	return f.expr.Log()
}

// Log10 以10为底的对数 (LOG10)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT LOG10(100); -- 结果为 2
func (f DecimalField[T]) Log10() FloatExpr[float64] {
	return f.expr.Log10()
}

// Log2 以2为底的对数 (LOG2)
// 数据库支持: MySQL (PostgreSQL/SQLite 不直接支持)
// SELECT LOG2(8); -- 结果为 3
func (f DecimalField[T]) Log2() FloatExpr[float64] {
	return f.expr.Log2()
}

// Exp 指数函数 (EXP)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT EXP(1); -- 结果为 2.718281828...
func (f DecimalField[T]) Exp() FloatExpr[float64] {
	return f.expr.Exp()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f DecimalField[T]) IfNull(defaultValue any) DecimalExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f DecimalField[T]) Coalesce(values ...any) DecimalExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f DecimalField[T]) NullIf(value any) DecimalExpr[T] {
	return f.expr.NullIf(value)
}

// Greatest 返回参数列表中的最大值 (GREATEST)
// 数据库支持: MySQL, PostgreSQL (SQLite 不支持)
// SELECT GREATEST(10, 20, 30); -- 返回 30
// SELECT GREATEST(price, min_price) FROM products;
func (f DecimalField[T]) Greatest(values ...any) DecimalExpr[T] {
	return f.expr.Greatest(values...)
}

// Least 返回参数列表中的最小值 (LEAST)
// 数据库支持: MySQL, PostgreSQL (SQLite 不支持)
// SELECT LEAST(10, 20, 30); -- 返回 10
// SELECT LEAST(price, max_price) FROM products;
func (f DecimalField[T]) Least(values ...any) DecimalExpr[T] {
	return f.expr.Least(values...)
}

// Sum 计算数值的总和 (SUM)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT SUM(quantity) FROM orders;
// SELECT user_id, SUM(points) FROM transactions GROUP BY user_id;
func (f DecimalField[T]) Sum() DecimalExpr[T] {
	return f.expr.Sum()
}

// Avg 计算数值的平均值 (AVG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT AVG(score) FROM students;
// SELECT class_id, AVG(grade) FROM exams GROUP BY class_id;
func (f DecimalField[T]) Avg() FloatExpr[float64] {
	return f.expr.Avg()
}

// Max 返回最大值 (MAX)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MAX(price) FROM products;
// SELECT category, MAX(stock) FROM inventory GROUP BY category;
func (f DecimalField[T]) Max() DecimalExpr[T] {
	return f.expr.Max()
}

// Min 返回最小值 (MIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MIN(price) FROM products;
// SELECT category, MIN(stock) FROM inventory GROUP BY category;
func (f DecimalField[T]) Min() DecimalExpr[T] {
	return f.expr.Min()
}

func (f DecimalField[T]) Gt(value T) Condition {
	return f.expr.Gt(value)
}

func (f DecimalField[T]) GtOpt(value mo.Option[T]) Condition {
	return f.expr.GtOpt(value)
}

func (f DecimalField[T]) GtF(other clause.Expression) Condition {
	return f.expr.GtF(other)
}

func (f DecimalField[T]) Gte(value T) Condition {
	return f.expr.Gte(value)
}

func (f DecimalField[T]) GteOpt(value mo.Option[T]) Condition {
	return f.expr.GteOpt(value)
}

func (f DecimalField[T]) GteF(other clause.Expression) Condition {
	return f.expr.GteF(other)
}

func (f DecimalField[T]) Lt(value T) Condition {
	return f.expr.Lt(value)
}

func (f DecimalField[T]) LtOpt(value mo.Option[T]) Condition {
	return f.expr.LtOpt(value)
}

func (f DecimalField[T]) LtF(other clause.Expression) Condition {
	return f.expr.LtF(other)
}

func (f DecimalField[T]) Lte(value T) Condition {
	return f.expr.Lte(value)
}

func (f DecimalField[T]) LteOpt(value mo.Option[T]) Condition {
	return f.expr.LteOpt(value)
}

func (f DecimalField[T]) LteF(other clause.Expression) Condition {
	return f.expr.LteF(other)
}

// Between 范围查询（使用组合条件而非 SQL BETWEEN 语法）
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
// 默认形成左闭右开区间: from <= field < to
// 示例: field.Between(1, 10) => field >= 1 AND field < 10
// 示例: field.Between(1, 10, ">", "<=") => field > 1 AND field <= 10
func (f DecimalField[T]) Between(from *T, to *T, op ...string) Condition {
	return f.expr.Between(from, to, op...)
}

// NotBetween 范围排除查询（使用 OR 组合条件）
// opFrom: >=, >, =, <=, < 默认: <（NotBetween 的 from 条件是小于）
// opTo: >=, >, =, <=, < 默认: >=（NotBetween 的 to 条件是大于等于）
// 默认: field < from OR field >= to
// 示例: field.NotBetween(1, 10) => field < 1 OR field >= 10
func (f DecimalField[T]) NotBetween(from *T, to *T, op ...string) Condition {
	return f.expr.NotBetween(from, to, op...)
}

// BetweenRange 使用 Range 参数的范围查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f DecimalField[T]) BetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.BetweenRange(rng, op...)
}

// BetweenOpt 使用 Option 参数的范围查询
func (f DecimalField[T]) BetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.BetweenOpt(from, to, op...)
}

// BetweenF 使用字段参数的范围查询
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f DecimalField[T]) BetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.BetweenF(from, to, op...)
}

// NotBetweenRange 使用 Range 参数的范围排除查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
// 示例: field < from OR field >= to
func (f DecimalField[T]) NotBetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.NotBetweenRange(rng, op...)
}

// NotBetweenOpt 使用 Option 参数的范围排除查询
func (f DecimalField[T]) NotBetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.NotBetweenOpt(from, to, op...)
}

// NotBetweenF 使用字段参数的范围排除查询
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
func (f DecimalField[T]) NotBetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.NotBetweenF(from, to, op...)
}

func (f DecimalField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f DecimalField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f DecimalField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f DecimalField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f DecimalField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f DecimalField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f DecimalField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f DecimalField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f DecimalField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f DecimalField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f DecimalField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f DecimalField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== StringField ====================

type StringField[T any] struct {
	expr   StringExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func StringFieldOf[T any](tableName, name string, flags ...types.FieldFlag) StringField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := StringField[T]{
		expr:   StringOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func StringColumn[T any](name string) StringColumnBuilder[T] {
	return StringColumnBuilder[T]{name: name}
}

type StringColumnBuilder[T any] struct {
	name string
}

func (b StringColumnBuilder[T]) From(source interface{ TableName() string }) StringField[T] {
	return StringFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f StringField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f StringField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f StringField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f StringField[T]) Expr() StringExpr[T] {
	return f.expr
}

func (f StringField[T]) Apply(functionName FunctionName) StringExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return StringOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f StringField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f StringField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f StringField[T]) Name() string {
	return f.column.Name()
}

func (f StringField[T]) Alias() string {
	return f.column.Alias
}

func (f StringField[T]) FullName() string {
	return f.column.FullName()
}

func (f StringField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f StringField[T]) WithAlias(alias string) StringField[T] {
	ret := StringFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f StringField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) StringField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return StringFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f StringField[T]) FieldType() T {
	var def T
	return def
}

func (f StringField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f StringField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f StringField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f StringField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f StringField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f StringField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from StringExpr ///////////////

// Cast 类型转换 (CAST)
// SELECT CAST(price AS SIGNED) FROM products;
// SELECT CAST(amount AS DECIMAL(10,2)) FROM orders;
// targetType: SIGNED, UNSIGNED, DECIMAL(m,n), CHAR, DATE, DATETIME, TIME, BINARY 等
func (f StringField[T]) Cast(targetType string) clause.Expression {
	return f.expr.Cast(targetType)
}

// CastSigned 转换为有符号整数 (CAST AS SIGNED)
func (f StringField[T]) CastSigned() IntExpr[int64] {
	return f.expr.CastSigned()
}

// CastUnsigned 转换为无符号整数 (CAST AS UNSIGNED)
func (f StringField[T]) CastUnsigned() IntExpr[uint64] {
	return f.expr.CastUnsigned()
}

// CastJson 转换为JSON (CAST AS JSON)
func (f StringField[T]) CastJson() JsonExpr[string] {
	return f.expr.CastJson()
}

// CastDecimal 转换为小数 (CAST AS DECIMAL)
// precision: 总位数, scale: 小数位数
func (f StringField[T]) CastDecimal(precision int, scale int) DecimalExpr[float64] {
	return f.expr.CastDecimal(precision, scale)
}

// CastChar 转换为字符串 (CAST AS CHAR)
func (f StringField[T]) CastChar(length ...int) StringExpr[string] {
	return f.expr.CastChar(length...)
}

// Upper 将字符串转换为大写 (UPPER)，只对英文字母有效
// SELECT UPPER('hello world');
// SELECT UPPER(users.username) FROM users;
// SELECT * FROM products WHERE UPPER(product_code) = 'ABC123';
// UPDATE users SET username = UPPER(username) WHERE id = 1;
func (f StringField[T]) Upper() StringExpr[T] {
	return f.expr.Upper()
}

// Lower 将字符串转换为小写 (LOWER)，只对英文字母有效
// SELECT LOWER('HELLO WORLD');
// SELECT LOWER(users.email) FROM users;
// SELECT * FROM users WHERE LOWER(username) = 'admin';
// UPDATE users SET email = LOWER(email);
func (f StringField[T]) Lower() StringExpr[T] {
	return f.expr.Lower()
}

// Trim 去除字符串两端的空格 (TRIM)
// SELECT TRIM('  Hello World  ');
// SELECT TRIM(users.username) FROM users;
// UPDATE users SET email = TRIM(email);
func (f StringField[T]) Trim() StringExpr[T] {
	return f.expr.Trim()
}

// LTrim 去除字符串左侧的空格 (LTRIM)
// SELECT LTRIM('  Hello World  ');
// SELECT LTRIM(users.name) FROM users;
// SELECT * FROM products WHERE LTRIM(code) != code;
// UPDATE users SET username = LTRIM(username);
func (f StringField[T]) LTrim() StringExpr[T] {
	return f.expr.LTrim()
}

// RTrim 去除字符串右侧的空格 (RTRIM)
// SELECT RTRIM('  Hello World  ');
// SELECT RTRIM(description) FROM products;
// SELECT * FROM users WHERE RTRIM(email) != email;
// UPDATE articles SET title = RTRIM(title);
func (f StringField[T]) RTrim() StringExpr[T] {
	return f.expr.RTrim()
}

// Substring 从字符串中提取子字符串 (SUBSTRING)，位置从1开始
// SELECT SUBSTRING('Hello World', 1, 5);
// SELECT SUBSTRING(users.email, 1, LOCATE('@', users.email) - 1) FROM users;
// SELECT SUBSTRING(product_code, 4, 3) FROM products;
// pos: 起始位置（从1开始）, length: 长度
func (f StringField[T]) Substring(pos int, length int) StringExpr[T] {
	return f.expr.Substring(pos, length)
}

// Left 从字符串左侧提取指定长度的子字符串 (LEFT)
// SELECT LEFT('Hello World', 5);
// SELECT LEFT(users.name, 1) as initial FROM users;
// SELECT * FROM products WHERE LEFT(product_code, 2) = 'AB';
// SELECT LEFT(email, LOCATE('@', email) - 1) FROM users;
func (f StringField[T]) Left(length int) StringExpr[T] {
	return f.expr.Left(length)
}

// Right 从字符串右侧提取指定长度的子字符串 (RIGHT)
// SELECT RIGHT('Hello World', 5);
// SELECT RIGHT(phone, 4) as last_four FROM users;
// SELECT * FROM files WHERE RIGHT(filename, 4) = '.pdf';
// SELECT RIGHT(product_code, 3) FROM products;
func (f StringField[T]) Right(length int) StringExpr[T] {
	return f.expr.Right(length)
}

// Length 返回字符串的字节长度 (LENGTH)
// SELECT LENGTH('Hello');
// SELECT LENGTH('你好');
// SELECT users.name, LENGTH(users.name) FROM users;
// SELECT * FROM products WHERE LENGTH(product_code) = 8;
// 注意: UTF-8编码中一个中文字符通常占3个字节
func (f StringField[T]) Length() IntExpr[int64] {
	return f.expr.Length()
}

// CharLength 返回字符串的字符长度 (CHAR_LENGTH)，多字节字符按一个字符计算
// SELECT CHAR_LENGTH('Hello');
// SELECT CHAR_LENGTH('你好');
// SELECT users.name, CHAR_LENGTH(users.name) FROM users;
// SELECT * FROM articles WHERE CHAR_LENGTH(content) > 1000;
func (f StringField[T]) CharLength() IntExpr[int64] {
	return f.expr.CharLength()
}

// Concat 拼接多个字符串 (CONCAT)，任意参数为NULL则返回NULL
// SELECT CONCAT('Hello', ' ', 'World');
// SELECT CONCAT(users.first_name, ' ', users.last_name) as full_name FROM users;
// SELECT CONCAT('User:', users.id) FROM users;
// SELECT CONCAT(YEAR(NOW()), '-', MONTH(NOW()));
func (f StringField[T]) Concat(args ...clause.Expression) StringExpr[T] {
	return f.expr.Concat(args...)
}

// ConcatWS 用指定分隔符拼接多个字符串 (CONCAT_WS)，自动跳过NULL值
// SELECT CONCAT_WS(',', 'A', 'B', 'C'); -- 结果为 'A,B,C'
// SELECT CONCAT_WS('-', users.last_name, users.first_name) FROM users;
// SELECT CONCAT_WS('/', YEAR(date), MONTH(date), DAY(date)) FROM logs;
// SELECT CONCAT_WS(', ', city, state, country) FROM addresses;
// 注意：分隔符为NULL则返回NULL，但参数中的NULL会被跳过
func (f StringField[T]) ConcatWS(separator string, args ...clause.Expression) StringExpr[T] {
	return f.expr.ConcatWS(separator, args...)
}

// Replace 替换字符串中所有出现的子字符串 (REPLACE)
// SELECT REPLACE('Hello World', 'World', 'MySQL');
// SELECT REPLACE('www.example.com', 'www', 'mail');
// SELECT REPLACE(phone, '-', ”) FROM users;
// UPDATE products SET description = REPLACE(description, 'old', 'new');
func (f StringField[T]) Replace(from string, to string) StringExpr[T] {
	return f.expr.Replace(from, to)
}

// Locate 查找子字符串位置 (LOCATE)
// SELECT LOCATE('@', email) FROM users;
// 返回子字符串第一次出现的位置（从1开始），未找到返回0
func (f StringField[T]) Locate(substr string) IntExpr[int64] {
	return f.expr.Locate(substr)
}

// Reverse 反转字符串 (REVERSE)
// SELECT REVERSE(name) FROM users;
func (f StringField[T]) Reverse() StringExpr[T] {
	return f.expr.Reverse()
}

// Repeat 重复字符串 (REPEAT)
// SELECT REPEAT('*', 10);
func (f StringField[T]) Repeat(count int) StringExpr[T] {
	return f.expr.Repeat(count)
}

// LPad 左侧填充 (LPAD)
// SELECT LPAD(id, 5, '0') FROM users; -- 结果如 "00001"
func (f StringField[T]) LPad(length int, padStr string) StringExpr[T] {
	return f.expr.LPad(length, padStr)
}

// RPad 右侧填充 (RPAD)
// SELECT RPAD(name, 20, ' ') FROM users;
func (f StringField[T]) RPad(length int, padStr string) StringExpr[T] {
	return f.expr.RPad(length, padStr)
}

// ToDate 将字符串按照指定格式转换为日期/时间 (STR_TO_DATE)
// SELECT STR_TO_DATE('2023-10-26', '%Y-%m-%d');
// SELECT STR_TO_DATE('2023年10月26日', '%Y年%m月%d日');
// SELECT STR_TO_DATE('10/26/2023 10:30:45', '%m/%d/%Y %H:%i:%s');
// SELECT * FROM orders WHERE order_date = STR_TO_DATE('20231026', '%Y%m%d');
func (f StringField[T]) ToDate(format string) DateTimeExpr[string] {
	return f.expr.ToDate(format)
}

// InetAton 将点分十进制的IPv4地址转换为整数形式 (INET_ATON)
// SELECT INET_ATON('192.168.1.1'); -- 结果为 3232235777
// INSERT INTO ip_logs (ip_num) VALUES (INET_ATON('192.168.1.100'));
func (f StringField[T]) InetAton() IntExpr[uint32] {
	return f.expr.InetAton()
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f StringField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f StringField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f StringField[T]) IfNull(defaultValue any) StringExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f StringField[T]) Coalesce(values ...any) StringExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f StringField[T]) NullIf(value any) StringExpr[T] {
	return f.expr.NullIf(value)
}

func (f StringField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f StringField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f StringField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f StringField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f StringField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f StringField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f StringField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f StringField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f StringField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f StringField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f StringField[T]) Like(value T, escape ...byte) clause.Expression {
	return f.expr.Like(value, escape...)
}

func (f StringField[T]) LikeOpt(value mo.Option[T], escape ...byte) clause.Expression {
	return f.expr.LikeOpt(value, escape...)
}

func (f StringField[T]) NotLike(value T, escape ...byte) clause.Expression {
	return f.expr.NotLike(value, escape...)
}

func (f StringField[T]) NotLikeOpt(value mo.Option[T], escape ...byte) clause.Expression {
	return f.expr.NotLikeOpt(value, escape...)
}

func (f StringField[T]) Contains(value string) clause.Expression {
	return f.expr.Contains(value)
}

func (f StringField[T]) ContainsOpt(value mo.Option[string]) clause.Expression {
	return f.expr.ContainsOpt(value)
}

func (f StringField[T]) HasPrefix(value string) clause.Expression {
	return f.expr.HasPrefix(value)
}

func (f StringField[T]) HasPrefixOpt(value mo.Option[string]) clause.Expression {
	return f.expr.HasPrefixOpt(value)
}

func (f StringField[T]) HasSuffix(value string) clause.Expression {
	return f.expr.HasSuffix(value)
}

func (f StringField[T]) HasSuffixOpt(value mo.Option[string]) clause.Expression {
	return f.expr.HasSuffixOpt(value)
}

func (f StringField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f StringField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== DateTimeField ====================

type DateTimeField[T any] struct {
	expr   DateTimeExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func DateTimeFieldOf[T any](tableName, name string, flags ...types.FieldFlag) DateTimeField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := DateTimeField[T]{
		expr:   DateTimeOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func DateTimeColumn[T any](name string) DateTimeColumnBuilder[T] {
	return DateTimeColumnBuilder[T]{name: name}
}

type DateTimeColumnBuilder[T any] struct {
	name string
}

func (b DateTimeColumnBuilder[T]) From(source interface{ TableName() string }) DateTimeField[T] {
	return DateTimeFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f DateTimeField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f DateTimeField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f DateTimeField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f DateTimeField[T]) Expr() DateTimeExpr[T] {
	return f.expr
}

func (f DateTimeField[T]) Apply(functionName FunctionName) DateTimeExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return DateTimeOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DateTimeField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DateTimeField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DateTimeField[T]) Name() string {
	return f.column.Name()
}

func (f DateTimeField[T]) Alias() string {
	return f.column.Alias
}

func (f DateTimeField[T]) FullName() string {
	return f.column.FullName()
}

func (f DateTimeField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f DateTimeField[T]) WithAlias(alias string) DateTimeField[T] {
	ret := DateTimeFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f DateTimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateTimeField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return DateTimeFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f DateTimeField[T]) FieldType() T {
	var def T
	return def
}

func (f DateTimeField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DateTimeField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DateTimeField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DateTimeField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DateTimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateTimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from DateTimeExpr ///////////////

// Cast 类型转换 (CAST)
func (f DateTimeField[T]) Cast(targetType string) clause.Expression {
	return f.expr.Cast(targetType)
}

// CastDate 转换为 DATE 类型 (CAST AS DATE)
func (f DateTimeField[T]) CastDate() DateExpr[string] {
	return f.expr.CastDate()
}

// CastTime 转换为 TIME 类型 (CAST AS TIME)
func (f DateTimeField[T]) CastTime() TimeExpr[string] {
	return f.expr.CastTime()
}

// CastChar 转换为字符串 (CAST AS CHAR)
func (f DateTimeField[T]) CastChar(length ...int) StringExpr[string] {
	return f.expr.CastChar(length...)
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f DateTimeField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f DateTimeField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f DateTimeField[T]) IfNull(defaultValue any) DateTimeExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f DateTimeField[T]) Coalesce(values ...any) DateTimeExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f DateTimeField[T]) NullIf(value any) DateTimeExpr[T] {
	return f.expr.NullIf(value)
}

// Avg 计算数值的平均值 (AVG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT AVG(score) FROM students;
// SELECT class_id, AVG(grade) FROM exams GROUP BY class_id;
func (f DateTimeField[T]) Avg() FloatExpr[float64] {
	return f.expr.Avg()
}

// Max 返回最大值 (MAX)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MAX(price) FROM products;
// SELECT category, MAX(stock) FROM inventory GROUP BY category;
func (f DateTimeField[T]) Max() DateTimeExpr[T] {
	return f.expr.Max()
}

// Min 返回最小值 (MIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MIN(price) FROM products;
// SELECT category, MIN(stock) FROM inventory GROUP BY category;
func (f DateTimeField[T]) Min() DateTimeExpr[T] {
	return f.expr.Min()
}

// YearExpr 提取年份部分 (YEAR)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT YEAR(date_column) FROM table;
func (f DateTimeField[T]) Year() IntExpr[int] {
	return f.expr.Year()
}

// Month 提取月份部分 (MONTH)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MONTH(date_column) FROM table;
func (f DateTimeField[T]) Month() IntExpr[int] {
	return f.expr.Month()
}

// Day 提取天数部分 (DAY)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT DAY(date_column) FROM table;
func (f DateTimeField[T]) Day() IntExpr[int] {
	return f.expr.Day()
}

// DayOfMonth 提取一月中的天数 (DAYOFMONTH)
// 数据库支持: MySQL
// 与 DAY() 等价
func (f DateTimeField[T]) DayOfMonth() IntExpr[int] {
	return f.expr.DayOfMonth()
}

// DayOfWeek 返回一周中的索引 (DAYOFWEEK)
// 数据库支持: MySQL
// 1=周日, 2=周一, ..., 7=周六
func (f DateTimeField[T]) DayOfWeek() IntExpr[int] {
	return f.expr.DayOfWeek()
}

// DayOfYear 返回一年中的天数 (DAYOFYEAR)
// 数据库支持: MySQL
// 范围: 1-366
func (f DateTimeField[T]) DayOfYear() IntExpr[int] {
	return f.expr.DayOfYear()
}

// Week 提取周数 (WEEK)
// 数据库支持: MySQL
// 范围: 0-53
func (f DateTimeField[T]) Week() IntExpr[int] {
	return f.expr.Week()
}

// WeekOfYear 提取周数 (WEEKOFYEAR)
// 数据库支持: MySQL
// 范围: 1-53，相当于 WEEK(date, 3)
func (f DateTimeField[T]) WeekOfYear() IntExpr[int] {
	return f.expr.WeekOfYear()
}

// Quarter 提取季度 (QUARTER)
// 数据库支持: MySQL
// 范围: 1-4
func (f DateTimeField[T]) Quarter() IntExpr[int] {
	return f.expr.Quarter()
}

// LastDay 返回指定日期所在月份的最后一天 (LAST_DAY)
// 数据库支持: MySQL
// SELECT LAST_DAY('2024-02-15'); -- 返回 '2024-02-29'
func (f DateTimeField[T]) LastDay() DateExpr[string] {
	return f.expr.LastDay()
}

// DayName 返回日期的星期名称 (DAYNAME)
// 数据库支持: MySQL
// SELECT DAYNAME('2024-01-15'); -- 返回 'Monday'
func (f DateTimeField[T]) DayName() StringExpr[string] {
	return f.expr.DayName()
}

// MonthName 返回日期的月份名称 (MONTHNAME)
// 数据库支持: MySQL
// SELECT MONTHNAME('2024-01-15'); -- 返回 'January'
func (f DateTimeField[T]) MonthName() StringExpr[string] {
	return f.expr.MonthName()
}

// ToDays 将日期转换为天数（从公元0年开始）(TO_DAYS)
// 数据库支持: MySQL
// SELECT TO_DAYS('2024-01-15'); -- 返回 739259
func (f DateTimeField[T]) ToDays() IntExpr[int] {
	return f.expr.ToDays()
}

// Hour 提取小时部分 (HOUR)
// 数据库支持: MySQL, PostgreSQL, SQLite
// 范围: 0-23
func (f DateTimeField[T]) Hour() IntExpr[int] {
	return f.expr.Hour()
}

// Minute 提取分钟部分 (MINUTE)
// 数据库支持: MySQL, PostgreSQL, SQLite
// 范围: 0-59
func (f DateTimeField[T]) Minute() IntExpr[int] {
	return f.expr.Minute()
}

// Second 提取秒数部分 (SECOND)
// 数据库支持: MySQL, PostgreSQL, SQLite
// 范围: 0-59
func (f DateTimeField[T]) Second() IntExpr[int] {
	return f.expr.Second()
}

// Microsecond 提取微秒部分 (MICROSECOND)
// 数据库支持: MySQL
// 范围: 0-999999
func (f DateTimeField[T]) Microsecond() IntExpr[int] {
	return f.expr.Microsecond()
}

// TimeToSec 将时间转换为秒数 (TIME_TO_SEC)
// 数据库支持: MySQL
// SELECT TIME_TO_SEC('01:30:00'); -- 返回 5400
func (f DateTimeField[T]) TimeToSec() IntExpr[int] {
	return f.expr.TimeToSec()
}

// AddInterval 在日期/时间上增加时间间隔 (DATE_ADD)
// 数据库支持: MySQL
// interval 格式: "1 DAY", "2 MONTH", "1 YEAR" 等
// 支持单位: MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR
// SELECT DATE_ADD(date_column, INTERVAL 1 DAY) FROM table;
func (f DateTimeField[T]) AddInterval(interval string) DateTimeExpr[T] {
	return f.expr.AddInterval(interval)
}

// SubInterval 从日期/时间中减去时间间隔 (DATE_SUB)
// 数据库支持: MySQL
// interval 格式: "1 DAY", "2 MONTH", "1 YEAR" 等
// SELECT DATE_SUB(date_column, INTERVAL 1 MONTH) FROM table;
func (f DateTimeField[T]) SubInterval(interval string) DateTimeExpr[T] {
	return f.expr.SubInterval(interval)
}

// DateDiff 计算与另一个日期的差值（天数）(DATEDIFF)
// 数据库支持: MySQL
// 返回 this - other 的天数
// SELECT DATEDIFF(end_date, start_date) FROM events;
func (f DateTimeField[T]) DateDiff(other clause.Expression) IntExpr[int] {
	return f.expr.DateDiff(other)
}

// TimeDiff 计算与另一个时间的差值 (TIMEDIFF)
// 数据库支持: MySQL
// SELECT TIMEDIFF(end_time, start_time) FROM events;
func (f DateTimeField[T]) TimeDiff(other clause.Expression) TimeExpr[T] {
	return f.expr.TimeDiff(other)
}

// TimestampDiff 计算与另一个日期时间的差值（指定单位）(TIMESTAMPDIFF)
// 数据库支持: MySQL
// unit: MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR
// SELECT TIMESTAMPDIFF(DAY, start_date, end_date) FROM events;
func (f DateTimeField[T]) TimestampDiff(unit string, other clause.Expression) IntExpr[int64] {
	return f.expr.TimestampDiff(unit, other)
}

// DateFormat 格式化日期为字符串 (DATE_FORMAT)
// 数据库支持: MySQL
// SELECT DATE_FORMAT(date_column, '%Y年%m月%d日') FROM table;
func (f DateTimeField[T]) Format(format string) StringExpr[string] {
	return f.expr.Format(format)
}

// DateExpr 提取日期部分 (DATE)
// 数据库支持: MySQL
// SELECT DATE(datetime_column) FROM table;
func (f DateTimeField[T]) Date() DateExpr[string] {
	return f.expr.Date()
}

// TimeExpr 提取时间部分 (TIME)
// 数据库支持: MySQL
// SELECT TIME(datetime_column) FROM table;
func (f DateTimeField[T]) Time() TimeExpr[string] {
	return f.expr.Time()
}

// UnixTimestamp 转换为 Unix 时间戳（秒）(UNIX_TIMESTAMP)
// 数据库支持: MySQL
// SELECT UNIX_TIMESTAMP(date_column) FROM table;
func (f DateTimeField[T]) UnixTimestamp() IntExpr[int64] {
	return f.expr.UnixTimestamp()
}

func (f DateTimeField[T]) Gt(value T) Condition {
	return f.expr.Gt(value)
}

func (f DateTimeField[T]) GtOpt(value mo.Option[T]) Condition {
	return f.expr.GtOpt(value)
}

func (f DateTimeField[T]) GtF(other clause.Expression) Condition {
	return f.expr.GtF(other)
}

func (f DateTimeField[T]) Gte(value T) Condition {
	return f.expr.Gte(value)
}

func (f DateTimeField[T]) GteOpt(value mo.Option[T]) Condition {
	return f.expr.GteOpt(value)
}

func (f DateTimeField[T]) GteF(other clause.Expression) Condition {
	return f.expr.GteF(other)
}

func (f DateTimeField[T]) Lt(value T) Condition {
	return f.expr.Lt(value)
}

func (f DateTimeField[T]) LtOpt(value mo.Option[T]) Condition {
	return f.expr.LtOpt(value)
}

func (f DateTimeField[T]) LtF(other clause.Expression) Condition {
	return f.expr.LtF(other)
}

func (f DateTimeField[T]) Lte(value T) Condition {
	return f.expr.Lte(value)
}

func (f DateTimeField[T]) LteOpt(value mo.Option[T]) Condition {
	return f.expr.LteOpt(value)
}

func (f DateTimeField[T]) LteF(other clause.Expression) Condition {
	return f.expr.LteF(other)
}

// Between 范围查询（使用组合条件而非 SQL BETWEEN 语法）
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
// 默认形成左闭右开区间: from <= field < to
// 示例: field.Between(1, 10) => field >= 1 AND field < 10
// 示例: field.Between(1, 10, ">", "<=") => field > 1 AND field <= 10
func (f DateTimeField[T]) Between(from *T, to *T, op ...string) Condition {
	return f.expr.Between(from, to, op...)
}

// NotBetween 范围排除查询（使用 OR 组合条件）
// opFrom: >=, >, =, <=, < 默认: <（NotBetween 的 from 条件是小于）
// opTo: >=, >, =, <=, < 默认: >=（NotBetween 的 to 条件是大于等于）
// 默认: field < from OR field >= to
// 示例: field.NotBetween(1, 10) => field < 1 OR field >= 10
func (f DateTimeField[T]) NotBetween(from *T, to *T, op ...string) Condition {
	return f.expr.NotBetween(from, to, op...)
}

// BetweenRange 使用 Range 参数的范围查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f DateTimeField[T]) BetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.BetweenRange(rng, op...)
}

// BetweenOpt 使用 Option 参数的范围查询
func (f DateTimeField[T]) BetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.BetweenOpt(from, to, op...)
}

// BetweenF 使用字段参数的范围查询
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f DateTimeField[T]) BetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.BetweenF(from, to, op...)
}

// NotBetweenRange 使用 Range 参数的范围排除查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
// 示例: field < from OR field >= to
func (f DateTimeField[T]) NotBetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.NotBetweenRange(rng, op...)
}

// NotBetweenOpt 使用 Option 参数的范围排除查询
func (f DateTimeField[T]) NotBetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.NotBetweenOpt(from, to, op...)
}

// NotBetweenF 使用字段参数的范围排除查询
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
func (f DateTimeField[T]) NotBetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.NotBetweenF(from, to, op...)
}

func (f DateTimeField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f DateTimeField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f DateTimeField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f DateTimeField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f DateTimeField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f DateTimeField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f DateTimeField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f DateTimeField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f DateTimeField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f DateTimeField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f DateTimeField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f DateTimeField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== DateField ====================

type DateField[T any] struct {
	expr   DateExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func DateFieldOf[T any](tableName, name string, flags ...types.FieldFlag) DateField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := DateField[T]{
		expr:   DateOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func DateColumn[T any](name string) DateColumnBuilder[T] {
	return DateColumnBuilder[T]{name: name}
}

type DateColumnBuilder[T any] struct {
	name string
}

func (b DateColumnBuilder[T]) From(source interface{ TableName() string }) DateField[T] {
	return DateFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f DateField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f DateField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f DateField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f DateField[T]) Expr() DateExpr[T] {
	return f.expr
}

func (f DateField[T]) Apply(functionName FunctionName) DateExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return DateOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DateField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DateField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DateField[T]) Name() string {
	return f.column.Name()
}

func (f DateField[T]) Alias() string {
	return f.column.Alias
}

func (f DateField[T]) FullName() string {
	return f.column.FullName()
}

func (f DateField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f DateField[T]) WithAlias(alias string) DateField[T] {
	ret := DateFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f DateField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return DateFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f DateField[T]) FieldType() T {
	var def T
	return def
}

func (f DateField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DateField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DateField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DateField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DateField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from DateExpr ///////////////

// Cast 类型转换 (CAST)
func (f DateField[T]) Cast(targetType string) clause.Expression {
	return f.expr.Cast(targetType)
}

// CastDatetime 转换为 DATETIME 类型 (CAST AS DATETIME)
func (f DateField[T]) CastDatetime() DateTimeExpr[string] {
	return f.expr.CastDatetime()
}

// CastChar 转换为字符串 (CAST AS CHAR)
func (f DateField[T]) CastChar(length ...int) StringExpr[string] {
	return f.expr.CastChar(length...)
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f DateField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f DateField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f DateField[T]) IfNull(defaultValue any) DateExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f DateField[T]) Coalesce(values ...any) DateExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f DateField[T]) NullIf(value any) DateExpr[T] {
	return f.expr.NullIf(value)
}

// Avg 计算数值的平均值 (AVG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT AVG(score) FROM students;
// SELECT class_id, AVG(grade) FROM exams GROUP BY class_id;
func (f DateField[T]) Avg() FloatExpr[float64] {
	return f.expr.Avg()
}

// Max 返回最大值 (MAX)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MAX(price) FROM products;
// SELECT category, MAX(stock) FROM inventory GROUP BY category;
func (f DateField[T]) Max() DateExpr[T] {
	return f.expr.Max()
}

// Min 返回最小值 (MIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MIN(price) FROM products;
// SELECT category, MIN(stock) FROM inventory GROUP BY category;
func (f DateField[T]) Min() DateExpr[T] {
	return f.expr.Min()
}

// YearExpr 提取年份部分 (YEAR)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT YEAR(date_column) FROM table;
func (f DateField[T]) Year() IntExpr[int] {
	return f.expr.Year()
}

// Month 提取月份部分 (MONTH)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MONTH(date_column) FROM table;
func (f DateField[T]) Month() IntExpr[int] {
	return f.expr.Month()
}

// Day 提取天数部分 (DAY)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT DAY(date_column) FROM table;
func (f DateField[T]) Day() IntExpr[int] {
	return f.expr.Day()
}

// DayOfMonth 提取一月中的天数 (DAYOFMONTH)
// 数据库支持: MySQL
// 与 DAY() 等价
func (f DateField[T]) DayOfMonth() IntExpr[int] {
	return f.expr.DayOfMonth()
}

// DayOfWeek 返回一周中的索引 (DAYOFWEEK)
// 数据库支持: MySQL
// 1=周日, 2=周一, ..., 7=周六
func (f DateField[T]) DayOfWeek() IntExpr[int] {
	return f.expr.DayOfWeek()
}

// DayOfYear 返回一年中的天数 (DAYOFYEAR)
// 数据库支持: MySQL
// 范围: 1-366
func (f DateField[T]) DayOfYear() IntExpr[int] {
	return f.expr.DayOfYear()
}

// Week 提取周数 (WEEK)
// 数据库支持: MySQL
// 范围: 0-53
func (f DateField[T]) Week() IntExpr[int] {
	return f.expr.Week()
}

// WeekOfYear 提取周数 (WEEKOFYEAR)
// 数据库支持: MySQL
// 范围: 1-53，相当于 WEEK(date, 3)
func (f DateField[T]) WeekOfYear() IntExpr[int] {
	return f.expr.WeekOfYear()
}

// Quarter 提取季度 (QUARTER)
// 数据库支持: MySQL
// 范围: 1-4
func (f DateField[T]) Quarter() IntExpr[int] {
	return f.expr.Quarter()
}

// LastDay 返回指定日期所在月份的最后一天 (LAST_DAY)
// 数据库支持: MySQL
// SELECT LAST_DAY('2024-02-15'); -- 返回 '2024-02-29'
func (f DateField[T]) LastDay() DateExpr[string] {
	return f.expr.LastDay()
}

// DayName 返回日期的星期名称 (DAYNAME)
// 数据库支持: MySQL
// SELECT DAYNAME('2024-01-15'); -- 返回 'Monday'
func (f DateField[T]) DayName() StringExpr[string] {
	return f.expr.DayName()
}

// MonthName 返回日期的月份名称 (MONTHNAME)
// 数据库支持: MySQL
// SELECT MONTHNAME('2024-01-15'); -- 返回 'January'
func (f DateField[T]) MonthName() StringExpr[string] {
	return f.expr.MonthName()
}

// ToDays 将日期转换为天数（从公元0年开始）(TO_DAYS)
// 数据库支持: MySQL
// SELECT TO_DAYS('2024-01-15'); -- 返回 739259
func (f DateField[T]) ToDays() IntExpr[int] {
	return f.expr.ToDays()
}

// AddInterval 在日期/时间上增加时间间隔 (DATE_ADD)
// 数据库支持: MySQL
// interval 格式: "1 DAY", "2 MONTH", "1 YEAR" 等
// 支持单位: MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR
// SELECT DATE_ADD(date_column, INTERVAL 1 DAY) FROM table;
func (f DateField[T]) AddInterval(interval string) DateExpr[T] {
	return f.expr.AddInterval(interval)
}

// SubInterval 从日期/时间中减去时间间隔 (DATE_SUB)
// 数据库支持: MySQL
// interval 格式: "1 DAY", "2 MONTH", "1 YEAR" 等
// SELECT DATE_SUB(date_column, INTERVAL 1 MONTH) FROM table;
func (f DateField[T]) SubInterval(interval string) DateExpr[T] {
	return f.expr.SubInterval(interval)
}

// DateDiff 计算与另一个日期的差值（天数）(DATEDIFF)
// 数据库支持: MySQL
// 返回 this - other 的天数
// SELECT DATEDIFF(end_date, start_date) FROM events;
func (f DateField[T]) DateDiff(other clause.Expression) IntExpr[int] {
	return f.expr.DateDiff(other)
}

// DateFormat 格式化日期为字符串 (DATE_FORMAT)
// 数据库支持: MySQL
// SELECT DATE_FORMAT(date_column, '%Y年%m月%d日') FROM table;
func (f DateField[T]) Format(format string) StringExpr[string] {
	return f.expr.Format(format)
}

// UnixTimestamp 转换为 Unix 时间戳（秒）(UNIX_TIMESTAMP)
// 数据库支持: MySQL
// SELECT UNIX_TIMESTAMP(date_column) FROM table;
func (f DateField[T]) UnixTimestamp() IntExpr[int64] {
	return f.expr.UnixTimestamp()
}

func (f DateField[T]) Gt(value T) Condition {
	return f.expr.Gt(value)
}

func (f DateField[T]) GtOpt(value mo.Option[T]) Condition {
	return f.expr.GtOpt(value)
}

func (f DateField[T]) GtF(other clause.Expression) Condition {
	return f.expr.GtF(other)
}

func (f DateField[T]) Gte(value T) Condition {
	return f.expr.Gte(value)
}

func (f DateField[T]) GteOpt(value mo.Option[T]) Condition {
	return f.expr.GteOpt(value)
}

func (f DateField[T]) GteF(other clause.Expression) Condition {
	return f.expr.GteF(other)
}

func (f DateField[T]) Lt(value T) Condition {
	return f.expr.Lt(value)
}

func (f DateField[T]) LtOpt(value mo.Option[T]) Condition {
	return f.expr.LtOpt(value)
}

func (f DateField[T]) LtF(other clause.Expression) Condition {
	return f.expr.LtF(other)
}

func (f DateField[T]) Lte(value T) Condition {
	return f.expr.Lte(value)
}

func (f DateField[T]) LteOpt(value mo.Option[T]) Condition {
	return f.expr.LteOpt(value)
}

func (f DateField[T]) LteF(other clause.Expression) Condition {
	return f.expr.LteF(other)
}

// Between 范围查询（使用组合条件而非 SQL BETWEEN 语法）
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
// 默认形成左闭右开区间: from <= field < to
// 示例: field.Between(1, 10) => field >= 1 AND field < 10
// 示例: field.Between(1, 10, ">", "<=") => field > 1 AND field <= 10
func (f DateField[T]) Between(from *T, to *T, op ...string) Condition {
	return f.expr.Between(from, to, op...)
}

// NotBetween 范围排除查询（使用 OR 组合条件）
// opFrom: >=, >, =, <=, < 默认: <（NotBetween 的 from 条件是小于）
// opTo: >=, >, =, <=, < 默认: >=（NotBetween 的 to 条件是大于等于）
// 默认: field < from OR field >= to
// 示例: field.NotBetween(1, 10) => field < 1 OR field >= 10
func (f DateField[T]) NotBetween(from *T, to *T, op ...string) Condition {
	return f.expr.NotBetween(from, to, op...)
}

// BetweenRange 使用 Range 参数的范围查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f DateField[T]) BetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.BetweenRange(rng, op...)
}

// BetweenOpt 使用 Option 参数的范围查询
func (f DateField[T]) BetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.BetweenOpt(from, to, op...)
}

// BetweenF 使用字段参数的范围查询
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f DateField[T]) BetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.BetweenF(from, to, op...)
}

// NotBetweenRange 使用 Range 参数的范围排除查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
// 示例: field < from OR field >= to
func (f DateField[T]) NotBetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.NotBetweenRange(rng, op...)
}

// NotBetweenOpt 使用 Option 参数的范围排除查询
func (f DateField[T]) NotBetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.NotBetweenOpt(from, to, op...)
}

// NotBetweenF 使用字段参数的范围排除查询
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
func (f DateField[T]) NotBetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.NotBetweenF(from, to, op...)
}

func (f DateField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f DateField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f DateField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f DateField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f DateField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f DateField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f DateField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f DateField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f DateField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f DateField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f DateField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f DateField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== TimeField ====================

type TimeField[T any] struct {
	expr   TimeExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func TimeFieldOf[T any](tableName, name string, flags ...types.FieldFlag) TimeField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := TimeField[T]{
		expr:   TimeOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func TimeColumn[T any](name string) TimeColumnBuilder[T] {
	return TimeColumnBuilder[T]{name: name}
}

type TimeColumnBuilder[T any] struct {
	name string
}

func (b TimeColumnBuilder[T]) From(source interface{ TableName() string }) TimeField[T] {
	return TimeFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f TimeField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f TimeField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f TimeField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f TimeField[T]) Expr() TimeExpr[T] {
	return f.expr
}

func (f TimeField[T]) Apply(functionName FunctionName) TimeExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return TimeOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f TimeField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f TimeField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f TimeField[T]) Name() string {
	return f.column.Name()
}

func (f TimeField[T]) Alias() string {
	return f.column.Alias
}

func (f TimeField[T]) FullName() string {
	return f.column.FullName()
}

func (f TimeField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f TimeField[T]) WithAlias(alias string) TimeField[T] {
	ret := TimeFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f TimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TimeField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return TimeFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f TimeField[T]) FieldType() T {
	var def T
	return def
}

func (f TimeField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f TimeField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f TimeField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f TimeField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f TimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from TimeExpr ///////////////

// Cast 类型转换 (CAST)
func (f TimeField[T]) Cast(targetType string) clause.Expression {
	return f.expr.Cast(targetType)
}

// CastDatetime 转换为 DATETIME 类型 (CAST AS DATETIME)
// 注意：TIME 转 DATETIME 时，日期部分为当前日期
func (f TimeField[T]) CastDatetime() DateTimeExpr[string] {
	return f.expr.CastDatetime()
}

// CastChar 转换为字符串 (CAST AS CHAR)
func (f TimeField[T]) CastChar(length ...int) StringExpr[string] {
	return f.expr.CastChar(length...)
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f TimeField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f TimeField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f TimeField[T]) IfNull(defaultValue any) TimeExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f TimeField[T]) Coalesce(values ...any) TimeExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f TimeField[T]) NullIf(value any) TimeExpr[T] {
	return f.expr.NullIf(value)
}

// Avg 计算数值的平均值 (AVG)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT AVG(score) FROM students;
// SELECT class_id, AVG(grade) FROM exams GROUP BY class_id;
func (f TimeField[T]) Avg() FloatExpr[float64] {
	return f.expr.Avg()
}

// Max 返回最大值 (MAX)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MAX(price) FROM products;
// SELECT category, MAX(stock) FROM inventory GROUP BY category;
func (f TimeField[T]) Max() TimeExpr[T] {
	return f.expr.Max()
}

// Min 返回最小值 (MIN)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT MIN(price) FROM products;
// SELECT category, MIN(stock) FROM inventory GROUP BY category;
func (f TimeField[T]) Min() TimeExpr[T] {
	return f.expr.Min()
}

// Hour 提取小时部分 (HOUR)
// 数据库支持: MySQL, PostgreSQL, SQLite
// 范围: 0-23
func (f TimeField[T]) Hour() IntExpr[int] {
	return f.expr.Hour()
}

// Minute 提取分钟部分 (MINUTE)
// 数据库支持: MySQL, PostgreSQL, SQLite
// 范围: 0-59
func (f TimeField[T]) Minute() IntExpr[int] {
	return f.expr.Minute()
}

// Second 提取秒数部分 (SECOND)
// 数据库支持: MySQL, PostgreSQL, SQLite
// 范围: 0-59
func (f TimeField[T]) Second() IntExpr[int] {
	return f.expr.Second()
}

// Microsecond 提取微秒部分 (MICROSECOND)
// 数据库支持: MySQL
// 范围: 0-999999
func (f TimeField[T]) Microsecond() IntExpr[int] {
	return f.expr.Microsecond()
}

// TimeToSec 将时间转换为秒数 (TIME_TO_SEC)
// 数据库支持: MySQL
// SELECT TIME_TO_SEC('01:30:00'); -- 返回 5400
func (f TimeField[T]) TimeToSec() IntExpr[int] {
	return f.expr.TimeToSec()
}

// AddInterval 在日期/时间上增加时间间隔 (DATE_ADD)
// 数据库支持: MySQL
// interval 格式: "1 DAY", "2 MONTH", "1 YEAR" 等
// 支持单位: MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR
// SELECT DATE_ADD(date_column, INTERVAL 1 DAY) FROM table;
func (f TimeField[T]) AddInterval(interval string) TimeExpr[T] {
	return f.expr.AddInterval(interval)
}

// SubInterval 从日期/时间中减去时间间隔 (DATE_SUB)
// 数据库支持: MySQL
// interval 格式: "1 DAY", "2 MONTH", "1 YEAR" 等
// SELECT DATE_SUB(date_column, INTERVAL 1 MONTH) FROM table;
func (f TimeField[T]) SubInterval(interval string) TimeExpr[T] {
	return f.expr.SubInterval(interval)
}

// TimeDiff 计算与另一个时间的差值 (TIMEDIFF)
// 数据库支持: MySQL
// SELECT TIMEDIFF(end_time, start_time) FROM events;
func (f TimeField[T]) TimeDiff(other clause.Expression) TimeExpr[T] {
	return f.expr.TimeDiff(other)
}

// TimeFormat 格式化时间为字符串 (TIME_FORMAT)
// 数据库支持: MySQL
// SELECT TIME_FORMAT(time_column, '%H:%i:%s') FROM table;
func (f TimeField[T]) Format(format string) StringExpr[string] {
	return f.expr.Format(format)
}

func (f TimeField[T]) Gt(value T) Condition {
	return f.expr.Gt(value)
}

func (f TimeField[T]) GtOpt(value mo.Option[T]) Condition {
	return f.expr.GtOpt(value)
}

func (f TimeField[T]) GtF(other clause.Expression) Condition {
	return f.expr.GtF(other)
}

func (f TimeField[T]) Gte(value T) Condition {
	return f.expr.Gte(value)
}

func (f TimeField[T]) GteOpt(value mo.Option[T]) Condition {
	return f.expr.GteOpt(value)
}

func (f TimeField[T]) GteF(other clause.Expression) Condition {
	return f.expr.GteF(other)
}

func (f TimeField[T]) Lt(value T) Condition {
	return f.expr.Lt(value)
}

func (f TimeField[T]) LtOpt(value mo.Option[T]) Condition {
	return f.expr.LtOpt(value)
}

func (f TimeField[T]) LtF(other clause.Expression) Condition {
	return f.expr.LtF(other)
}

func (f TimeField[T]) Lte(value T) Condition {
	return f.expr.Lte(value)
}

func (f TimeField[T]) LteOpt(value mo.Option[T]) Condition {
	return f.expr.LteOpt(value)
}

func (f TimeField[T]) LteF(other clause.Expression) Condition {
	return f.expr.LteF(other)
}

// Between 范围查询（使用组合条件而非 SQL BETWEEN 语法）
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
// 默认形成左闭右开区间: from <= field < to
// 示例: field.Between(1, 10) => field >= 1 AND field < 10
// 示例: field.Between(1, 10, ">", "<=") => field > 1 AND field <= 10
func (f TimeField[T]) Between(from *T, to *T, op ...string) Condition {
	return f.expr.Between(from, to, op...)
}

// NotBetween 范围排除查询（使用 OR 组合条件）
// opFrom: >=, >, =, <=, < 默认: <（NotBetween 的 from 条件是小于）
// opTo: >=, >, =, <=, < 默认: >=（NotBetween 的 to 条件是大于等于）
// 默认: field < from OR field >= to
// 示例: field.NotBetween(1, 10) => field < 1 OR field >= 10
func (f TimeField[T]) NotBetween(from *T, to *T, op ...string) Condition {
	return f.expr.NotBetween(from, to, op...)
}

// BetweenRange 使用 Range 参数的范围查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f TimeField[T]) BetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.BetweenRange(rng, op...)
}

// BetweenOpt 使用 Option 参数的范围查询
func (f TimeField[T]) BetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.BetweenOpt(from, to, op...)
}

// BetweenF 使用字段参数的范围查询
// opFrom: >=, >, =, <=, < 默认: >=
// opTo: >=, >, =, <=, < 默认: <
func (f TimeField[T]) BetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.BetweenF(from, to, op...)
}

// NotBetweenRange 使用 Range 参数的范围排除查询
// rng: 任何实现 FromValue() *T 和 ToValue() *T 方法的类型
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
// 示例: field < from OR field >= to
func (f TimeField[T]) NotBetweenRange(rng interface {
	FromValue() *T
	ToValue() *T
}, op ...string) Condition {
	return f.expr.NotBetweenRange(rng, op...)
}

// NotBetweenOpt 使用 Option 参数的范围排除查询
func (f TimeField[T]) NotBetweenOpt(from mo.Option[T], to mo.Option[T], op ...string) Condition {
	return f.expr.NotBetweenOpt(from, to, op...)
}

// NotBetweenF 使用字段参数的范围排除查询
// opFrom: >=, >, =, <=, < 默认: <（小于 from）
// opTo: >=, >, =, <=, < 默认: >=（大于等于 to）
func (f TimeField[T]) NotBetweenF(from clause.Expression, to clause.Expression, op ...string) Condition {
	return f.expr.NotBetweenF(from, to, op...)
}

func (f TimeField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f TimeField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f TimeField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f TimeField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f TimeField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f TimeField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f TimeField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f TimeField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f TimeField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f TimeField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f TimeField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f TimeField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== ScalarField ====================

type ScalarField[T any] struct {
	expr   ScalarExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func ScalarFieldOf[T any](tableName, name string, flags ...types.FieldFlag) ScalarField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := ScalarField[T]{
		expr:   ScalarOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func ScalarColumn[T any](name string) ScalarColumnBuilder[T] {
	return ScalarColumnBuilder[T]{name: name}
}

type ScalarColumnBuilder[T any] struct {
	name string
}

func (b ScalarColumnBuilder[T]) From(source interface{ TableName() string }) ScalarField[T] {
	return ScalarFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f ScalarField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f ScalarField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f ScalarField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f ScalarField[T]) Expr() ScalarExpr[T] {
	return f.expr
}

func (f ScalarField[T]) Apply(functionName FunctionName) ScalarExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return ScalarOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f ScalarField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f ScalarField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f ScalarField[T]) Name() string {
	return f.column.Name()
}

func (f ScalarField[T]) Alias() string {
	return f.column.Alias
}

func (f ScalarField[T]) FullName() string {
	return f.column.FullName()
}

func (f ScalarField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f ScalarField[T]) WithAlias(alias string) ScalarField[T] {
	ret := ScalarFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f ScalarField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) ScalarField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return ScalarFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f ScalarField[T]) FieldType() T {
	var def T
	return def
}

func (f ScalarField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f ScalarField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f ScalarField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f ScalarField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f ScalarField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f ScalarField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from ScalarExpr ///////////////

func (f ScalarField[T]) ToString() StringExpr[T] {
	return f.expr.ToString()
}

func (f ScalarField[T]) ToInt() IntExpr[T] {
	return f.expr.ToInt()
}

func (f ScalarField[T]) ToFloat() FloatExpr[T] {
	return f.expr.ToFloat()
}

func (f ScalarField[T]) ToDecimal() DecimalExpr[T] {
	return f.expr.ToDecimal()
}

func (f ScalarField[T]) ToTime() TimeExpr[T] {
	return f.expr.ToTime()
}

func (f ScalarField[T]) ToDate() DateExpr[T] {
	return f.expr.ToDate()
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f ScalarField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f ScalarField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f ScalarField[T]) IfNull(defaultValue any) ScalarExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f ScalarField[T]) Coalesce(values ...any) ScalarExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f ScalarField[T]) NullIf(value any) ScalarExpr[T] {
	return f.expr.NullIf(value)
}

func (f ScalarField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f ScalarField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f ScalarField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f ScalarField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f ScalarField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f ScalarField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f ScalarField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f ScalarField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f ScalarField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f ScalarField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f ScalarField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f ScalarField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}

// ==================== JsonField ====================

type JsonField[T any] struct {
	expr   JsonExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func JsonFieldOf[T any](tableName, name string, flags ...types.FieldFlag) JsonField[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := JsonField[T]{
		expr:   JsonOf[T](q),
		column: q,
		flags:  0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func JsonColumn[T any](name string) JsonColumnBuilder[T] {
	return JsonColumnBuilder[T]{name: name}
}

type JsonColumnBuilder[T any] struct {
	name string
}

func (b JsonColumnBuilder[T]) From(source interface{ TableName() string }) JsonField[T] {
	return JsonFieldOf[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f JsonField[T]) Build(builder clause.Builder) {
	f.expr.Build(builder)
}

func (f JsonField[T]) ToExpr() clause.Expression {
	return f.expr
}

func (f JsonField[T]) Unwrap() clause.Expression {
	return f.expr
}

func (f JsonField[T]) Expr() JsonExpr[T] {
	return f.expr
}

func (f JsonField[T]) Apply(functionName FunctionName) JsonExpr[T] {
	var expr = f.expr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return JsonOf[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f JsonField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f JsonField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f JsonField[T]) Name() string {
	return f.column.Name()
}

func (f JsonField[T]) Alias() string {
	return f.column.Alias
}

func (f JsonField[T]) FullName() string {
	return f.column.FullName()
}

func (f JsonField[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f JsonField[T]) WithAlias(alias string) JsonField[T] {
	ret := JsonFieldOf[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f JsonField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) JsonField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return JsonFieldOf[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f JsonField[T]) FieldType() T {
	var def T
	return def
}

func (f JsonField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f JsonField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f JsonField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f JsonField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f JsonField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f JsonField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

/////////////// re-exported methods from JsonExpr ///////////////

// Extract 从 JSON 文档中提取数据 (JSON_EXTRACT)
// SELECT JSON_EXTRACT('{"name":"John","age":30}', '$.name');
// SELECT JSON_EXTRACT(data, '$.user.email') FROM profiles;
// 示例: gsql.JsonOf(u.Profile).Extract("$.name", "$.age")
func (f JsonField[T]) Extract(paths ...string) JsonExpr[T] {
	return f.expr.Extract(paths...)
}

// Unquote 去除 JSON 值的引号 (JSON_UNQUOTE)
// SELECT JSON_UNQUOTE('"Hello World"');
// SELECT JSON_UNQUOTE(JSON_EXTRACT(data, '$.name')) FROM users;
// 示例: gsql.JsonOf(u.Profile).Extract("$.name").Unquote()
func (f JsonField[T]) Unquote() StringExpr[string] {
	return f.expr.Unquote()
}

// Quote 为 JSON 值添加引号，使其成为有效的 JSON 字符串值 (JSON_QUOTE)
// SELECT JSON_QUOTE('Hello World');
// SELECT JSON_QUOTE(JSON_EXTRACT(data, '$.name')) FROM users;
// 示例: gsql.JsonOf(u.Profile).Extract("$.name").Quote()
func (f JsonField[T]) Quote() StringExpr[string] {
	return f.expr.Quote()
}

// Keys 返回 JSON 对象的键 (JSON_KEYS)
// SELECT JSON_KEYS('{"a":1,"b":2}');
// SELECT JSON_KEYS('{"a":{"x":1,"y":2},"b":3}', '$.a');
// 示例: gsql.JsonOf(u.Profile).Keys()
// 独立函数: gsql.JSON_KEYS(gsql.JsonOf(u.Profile))
func (f JsonField[T]) Keys(path ...string) JsonExpr[T] {
	return f.expr.Keys(path...)
}

// Length 返回 JSON 文档的长度 (JSON_LENGTH)
// SELECT JSON_LENGTH('[1,2,3]');
// SELECT JSON_LENGTH('{"a":1,"b":2}');
// 示例: gsql.JsonOf(u.Profile).Length("$.skills")
// 独立函数: gsql.JSON_LENGTH(gsql.JsonOf(u.Profile), "$.skills")
func (f JsonField[T]) Length(path ...string) IntExpr[int64] {
	return f.expr.Length(path...)
}

// Contains 检查是否包含指定值 (JSON_CONTAINS)
// SELECT JSON_CONTAINS('{"a":1,"b":2}', '1', '$.a');
// SELECT JSON_CONTAINS('[1,2,3]', '2');
// 示例: gsql.JsonOf(u.Profile).Contains(gsql.JsonLit(`"go"`), "$.skills")
// 独立函数: gsql.JSON_CONTAINS(gsql.JsonOf(u.Profile), gsql.JsonLit(`"go"`), "$.skills")
func (f JsonField[T]) Contains(candidate JsonInput, path ...string) IntExpr[int64] {
	return f.expr.Contains(candidate, path...)
}

// ContainsPath 检查路径是否存在 (JSON_CONTAINS_PATH)
// SELECT JSON_CONTAINS_PATH('{"a":1,"b":2}', 'one', '$.a', '$.c');
// SELECT JSON_CONTAINS_PATH('{"a":1,"b":2}', 'all', '$.a', '$.b');
// mode: 'one' 或 'all'
// 示例: gsql.JsonOf(u.Profile).ContainsPath("one", "$.name", "$.age")
// 独立函数: gsql.JSON_CONTAINS_PATH(gsql.JsonOf(u.Profile), "one", "$.name", "$.age")
func (f JsonField[T]) ContainsPath(mode string, paths ...string) IntExpr[int64] {
	return f.expr.ContainsPath(mode, paths...)
}

// Type 返回 JSON 值的类型 (JSON_TYPE)
// SELECT JSON_TYPE('{"a":1}');
// SELECT JSON_TYPE('[1,2,3]');
// 返回: OBJECT, ARRAY, INTEGER, DOUBLE, STRING, BOOLEAN, NULL
// 示例: gsql.JsonOf(u.Profile).Type()
// 独立函数: gsql.JSON_TYPE(gsql.JsonOf(u.Profile))
// TODO: 内部的Field也需要这个方法
func (f JsonField[T]) Type() StringExpr[string] {
	return f.expr.Type()
}

// Depth 返回 JSON 文档的最大深度 (JSON_DEPTH)
// SELECT JSON_DEPTH('{"a":{"b":{"c":1}}}');
// SELECT JSON_DEPTH('[1,[2,[3]]]');
// 示例: gsql.JsonOf(u.Profile).Depth()
func (f JsonField[T]) Depth() IntExpr[int64] {
	return f.expr.Depth()
}

// Valid 检查是否为有效 JSON (JSON_VALID)
// SELECT JSON_VALID('{"a":1}');
// SELECT JSON_VALID('invalid json');
// 示例: gsql.JsonOf(u.Profile).Valid()
// TODO: 内部的Field也需要这个方法
func (f JsonField[T]) Valid() IntExpr[int64] {
	return f.expr.Valid()
}

// Pretty 格式化输出 JSON (JSON_PRETTY)
// SELECT JSON_PRETTY('{"a":1,"b":2}');
// 示例: gsql.JsonOf(u.Profile).Pretty()
// 独立函数: gsql.JSON_PRETTY(gsql.JsonOf(u.Profile))
func (f JsonField[T]) Pretty() StringExpr[string] {
	return f.expr.Pretty()
}

// StorageSize 返回存储 JSON 所需的字节数 (JSON_STORAGE_SIZE)
// SELECT JSON_STORAGE_SIZE('{"a":1}');
// SELECT JSON_STORAGE_SIZE('[1,2,3,4,5]');
// 示例: gsql.JsonOf(u.Profile).StorageSize()
// 独立函数: gsql.JSON_STORAGE_SIZE(gsql.JsonOf(u.Profile))
func (f JsonField[T]) StorageSize() IntExpr[int64] {
	return f.expr.StorageSize()
}

// StorageFree 返回部分更新后释放的空间 (JSON_STORAGE_FREE)
// SELECT JSON_STORAGE_FREE(data) FROM users;
// 示例: gsql.JsonOf(u.Profile).StorageFree()
func (f JsonField[T]) StorageFree() IntExpr[int64] {
	return f.expr.StorageFree()
}

// Search 在 JSON 中搜索字符串值 (JSON_SEARCH)
// SELECT JSON_SEARCH('{"a":"abc","b":"def"}', 'one', 'abc');
// SELECT JSON_SEARCH('["abc","def","abc"]', 'all', 'abc');
// mode: 'one' 或 'all'
// 示例: gsql.JsonOf(u.Profile).Search("one", "abc")
func (f JsonField[T]) Search(mode string, searchStr any, escapePath ...any) StringExpr[string] {
	return f.expr.Search(mode, searchStr, escapePath...)
}

// Set 设置 JSON 值 (JSON_SET) - 返回 JsonExpr，支持链式设置
// SELECT JSON_SET('{"a":1}', '$.b', 2);
// 示例: gsql.JsonOf(u.Profile).Set("$.name", "John").Set("$.age", 18)
func (f JsonField[T]) Set(path string, value any) JsonExpr[T] {
	return f.expr.Set(path, value)
}

// Insert 插入 JSON 值，仅当路径不存在时 (JSON_INSERT)
// SELECT JSON_INSERT('{"a":1}', '$.b', 2);
// 示例: gsql.JsonOf(u.Profile).Insert("$.created_at", now)
// 独立函数: gsql.JSON_INSERT(gsql.JsonOf(u.Profile), "$.created_at", now)
func (f JsonField[T]) Insert(path string, value any) JsonExpr[T] {
	return f.expr.Insert(path, value)
}

// Replace 替换 JSON 值，仅当路径存在时 (JSON_REPLACE)
// SELECT JSON_REPLACE('{"a":1}', '$.a', 2);
// 示例: gsql.JsonOf(u.Profile).Replace("$.status", "inactive")
// 独立函数: gsql.JSON_REPLACE(gsql.JsonOf(u.Profile), "$.status", "inactive")
func (f JsonField[T]) Replace(path string, value any) JsonExpr[T] {
	return f.expr.Replace(path, value)
}

// Remove 移除 JSON 元素 (JSON_REMOVE)
// SELECT JSON_REMOVE('{"a":1,"b":2}', '$.a');
// 示例: gsql.JsonOf(u.Profile).Remove("$.temp", "$.old")
func (f JsonField[T]) Remove(paths ...string) JsonExpr[T] {
	return f.expr.Remove(paths...)
}

// ArrayAppend 向 JSON 数组追加值 (JSON_ARRAY_APPEND)
// SELECT JSON_ARRAY_APPEND('[1,2]', '$', 3);
// 示例: gsql.JsonOf(u.Tags).ArrayAppend("$", "new_tag")
// 独立函数: gsql.JSON_ARRAY_APPEND(gsql.JsonOf(u.Tags), "$", "new_tag")
func (f JsonField[T]) ArrayAppend(path string, value any) JsonExpr[T] {
	return f.expr.ArrayAppend(path, value)
}

// ArrayInsert 向 JSON 数组插入值 (JSON_ARRAY_INSERT)
// SELECT JSON_ARRAY_INSERT('[1,2]', '$[0]', 0);
// 示例: gsql.JsonOf(u.Images).ArrayInsert("$[0]", "cover.jpg")
// 独立函数: gsql.JSON_ARRAY_INSERT(gsql.JsonOf(u.Images), "$[0]", "cover.jpg")
func (f JsonField[T]) ArrayInsert(path string, value any) JsonExpr[T] {
	return f.expr.ArrayInsert(path, value)
}

// MergePreserve 合并 JSON，保留重复键 (JSON_MERGE_PRESERVE)
// SELECT JSON_MERGE_PRESERVE('{"a":1}', '{"b":2}');
// 示例: gsql.JsonOf(json1).MergePreserve(json2, json3)
// 独立函数: gsql.JSON_MERGE_PRESERVE(json1, json2).Merge(json3)
func (f JsonField[T]) MergePreserve(others ...JsonInput) JsonExpr[T] {
	return f.expr.MergePreserve(others...)
}

// MergePatch 合并 JSON，覆盖重复键 (JSON_MERGE_PATCH)
// SELECT JSON_MERGE_PATCH('{"a":1}', '{"a":2}');
// 示例: gsql.JsonOf(json1).MergePatch(json2, json3)
// 独立函数: gsql.JSON_MERGE_PATCH(json1, json2).Merge(json3)
func (f JsonField[T]) MergePatch(others ...JsonInput) JsonExpr[T] {
	return f.expr.MergePatch(others...)
}

// Overlaps 检查两个 JSON 是否有重叠元素 (JSON_OVERLAPS, MySQL 8.0.17+)
// SELECT JSON_OVERLAPS('[1,3,5]', '[2,3,4]');
// SELECT JSON_OVERLAPS('{"a":1}', '{"a":1,"b":2}');
// 示例: gsql.JsonOf(u.Tags).Overlaps(gsql.JsonLit(`["go","python"]`))
func (f JsonField[T]) Overlaps(other JsonInput) IntExpr[int64] {
	return f.expr.Overlaps(other)
}

// Value 从 JSON 文档中提取标量值 (JSON_VALUE, MySQL 8.0.21+)
// SELECT JSON_VALUE('{"name":"John"}', '$.name');
// SELECT JSON_VALUE('{"age":30}', '$.age' RETURNING SIGNED);
// 示例: gsql.JsonOf(u.Profile).Value("$.name")
// 注意: 比 Extract + Unquote 更简洁，直接返回标量值
func (f JsonField[T]) Value(path string) StringExpr[string] {
	return f.expr.Value(path)
}

func (f JsonField[T]) ToScalar() ScalarExpr[string] {
	return f.expr.ToScalar()
}

// Count 计算非NULL值的数量 (COUNT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(id) FROM users;
// SELECT status, COUNT(id) FROM orders GROUP BY status;
func (f JsonField[T]) Count() IntExpr[int64] {
	return f.expr.Count()
}

// CountDistinct 计算不重复非NULL值的数量 (COUNT DISTINCT)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT COUNT(DISTINCT status) FROM orders;
// SELECT user_id, COUNT(DISTINCT product_id) FROM cart GROUP BY user_id;
func (f JsonField[T]) CountDistinct() IntExpr[int64] {
	return f.expr.CountDistinct()
}

// IfNull 如果表达式为NULL则返回默认值
// 内部使用 COALESCE 实现，等价于 Coalesce(defaultValue)
func (f JsonField[T]) IfNull(defaultValue any) JsonExpr[T] {
	return f.expr.IfNull(defaultValue)
}

// Coalesce 返回参数列表中第一个非NULL的值 (COALESCE)
// 数据库支持: MySQL, PostgreSQL, SQLite (SQL 标准函数)
// SELECT COALESCE(nickname, username, 'Anonymous') FROM users;
func (f JsonField[T]) Coalesce(values ...any) JsonExpr[T] {
	return f.expr.Coalesce(values...)
}

// NullIf 如果两个表达式相等则返回NULL，否则返回第一个表达式 (NULLIF)
// 数据库支持: MySQL, PostgreSQL, SQLite
// SELECT NULLIF(username, ") FROM users; -- 空字符串转为NULL
func (f JsonField[T]) NullIf(value any) JsonExpr[T] {
	return f.expr.NullIf(value)
}

func (f JsonField[T]) Eq(value T) Condition {
	return f.expr.Eq(value)
}

func (f JsonField[T]) EqF(other clause.Expression) Condition {
	return f.expr.EqF(other)
}

func (f JsonField[T]) EqOpt(value mo.Option[T]) Condition {
	return f.expr.EqOpt(value)
}

func (f JsonField[T]) Not(value T) Condition {
	return f.expr.Not(value)
}

func (f JsonField[T]) NotF(other clause.Expression) Condition {
	return f.expr.NotF(other)
}

func (f JsonField[T]) NotOpt(value mo.Option[T]) Condition {
	return f.expr.NotOpt(value)
}

func (f JsonField[T]) In(values ...T) Condition {
	return f.expr.In(values...)
}

func (f JsonField[T]) NotIn(values ...T) Condition {
	return f.expr.NotIn(values...)
}

// InSubquery 用于子查询的 IN 条件
// 示例: WHERE id IN (SELECT customer_id FROM orders)
func (f JsonField[T]) InSubquery(subquery clause.Expression) Condition {
	return f.expr.InSubquery(subquery)
}

// NotInSubquery 用于子查询的 NOT IN 条件
// 示例: WHERE id NOT IN (SELECT customer_id FROM orders)
func (f JsonField[T]) NotInSubquery(subquery clause.Expression) Condition {
	return f.expr.NotInSubquery(subquery)
}

func (f JsonField[T]) IsNull() Condition {
	return f.expr.IsNull()
}

func (f JsonField[T]) IsNotNull() Condition {
	return f.expr.IsNotNull()
}
