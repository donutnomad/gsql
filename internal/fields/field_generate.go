// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/clauses2"
	"github.com/donutnomad/gsql/internal/fieldi"
	"github.com/donutnomad/gsql/internal/types"
)

// ==================== IntField ====================

type IntField[T any] struct {
	IntExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewIntField[T any](tableName, name string, flags ...types.FieldFlag) IntField[T] {
	ret := newIntFieldFromExpr[T](nil, tableName, name, "")
	ret.IntExpr = IntOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newIntFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) IntField[T] {
	return IntField[T]{
		IntExpr: IntOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f IntField[T]) Build(builder clause.Builder) {
	f.IntExpr.Build(builder)
}

func (f IntField[T]) ToExpr() clause.Expression {
	return f.IntExpr
}

func (f IntField[T]) Unwrap() clause.Expression {
	return f.IntExpr
}

func (f IntField[T]) Expr() IntExpr[T] {
	return f.IntExpr
}

func (f IntField[T]) Wrap(functionName FunctionName) IntField[T] {
	var expr = f.IntExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newIntFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f IntField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f IntField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f IntField[T]) Name() string {
	return f.column.Name()
}

func (f IntField[T]) Alias() string {
	return f.column.Alias
}

func (f IntField[T]) FullName() string {
	return f.column.FullName()
}

func (f IntField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newIntFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f IntField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) IntField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewIntField[T](tableName.TableName(), name)
}

func (f IntField[T]) WithAlias(alias string) IntField[T] {
	ret := NewIntField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f IntField[T]) FieldType() T {
	var def T
	return def
}

func (f IntField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f IntField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f IntField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f IntField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f IntField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f IntField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== FloatField ====================

type FloatField[T any] struct {
	FloatExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewFloatField[T any](tableName, name string, flags ...types.FieldFlag) FloatField[T] {
	ret := newFloatFieldFromExpr[T](nil, tableName, name, "")
	ret.FloatExpr = FloatOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newFloatFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) FloatField[T] {
	return FloatField[T]{
		FloatExpr: FloatOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f FloatField[T]) Build(builder clause.Builder) {
	f.FloatExpr.Build(builder)
}

func (f FloatField[T]) ToExpr() clause.Expression {
	return f.FloatExpr
}

func (f FloatField[T]) Unwrap() clause.Expression {
	return f.FloatExpr
}

func (f FloatField[T]) Expr() FloatExpr[T] {
	return f.FloatExpr
}

func (f FloatField[T]) Wrap(functionName FunctionName) FloatField[T] {
	var expr = f.FloatExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newFloatFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f FloatField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f FloatField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f FloatField[T]) Name() string {
	return f.column.Name()
}

func (f FloatField[T]) Alias() string {
	return f.column.Alias
}

func (f FloatField[T]) FullName() string {
	return f.column.FullName()
}

func (f FloatField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newFloatFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f FloatField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) FloatField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewFloatField[T](tableName.TableName(), name)
}

func (f FloatField[T]) WithAlias(alias string) FloatField[T] {
	ret := NewFloatField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f FloatField[T]) FieldType() T {
	var def T
	return def
}

func (f FloatField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f FloatField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f FloatField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f FloatField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f FloatField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f FloatField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DecimalField ====================

type DecimalField[T any] struct {
	DecimalExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewDecimalField[T any](tableName, name string, flags ...types.FieldFlag) DecimalField[T] {
	ret := newDecimalFieldFromExpr[T](nil, tableName, name, "")
	ret.DecimalExpr = DecimalOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newDecimalFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) DecimalField[T] {
	return DecimalField[T]{
		DecimalExpr: DecimalOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f DecimalField[T]) Build(builder clause.Builder) {
	f.DecimalExpr.Build(builder)
}

func (f DecimalField[T]) ToExpr() clause.Expression {
	return f.DecimalExpr
}

func (f DecimalField[T]) Unwrap() clause.Expression {
	return f.DecimalExpr
}

func (f DecimalField[T]) Expr() DecimalExpr[T] {
	return f.DecimalExpr
}

func (f DecimalField[T]) Wrap(functionName FunctionName) DecimalField[T] {
	var expr = f.DecimalExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newDecimalFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DecimalField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DecimalField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DecimalField[T]) Name() string {
	return f.column.Name()
}

func (f DecimalField[T]) Alias() string {
	return f.column.Alias
}

func (f DecimalField[T]) FullName() string {
	return f.column.FullName()
}

func (f DecimalField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newDecimalFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f DecimalField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DecimalField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDecimalField[T](tableName.TableName(), name)
}

func (f DecimalField[T]) WithAlias(alias string) DecimalField[T] {
	ret := NewDecimalField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f DecimalField[T]) FieldType() T {
	var def T
	return def
}

func (f DecimalField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DecimalField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DecimalField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DecimalField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DecimalField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DecimalField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== StringField ====================

type StringField[T any] struct {
	StringExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewStringField[T any](tableName, name string, flags ...types.FieldFlag) StringField[T] {
	ret := newStringFieldFromExpr[T](nil, tableName, name, "")
	ret.StringExpr = StringOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newStringFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) StringField[T] {
	return StringField[T]{
		StringExpr: StringOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f StringField[T]) Build(builder clause.Builder) {
	f.StringExpr.Build(builder)
}

func (f StringField[T]) ToExpr() clause.Expression {
	return f.StringExpr
}

func (f StringField[T]) Unwrap() clause.Expression {
	return f.StringExpr
}

func (f StringField[T]) Expr() StringExpr[T] {
	return f.StringExpr
}

func (f StringField[T]) Wrap(functionName FunctionName) StringField[T] {
	var expr = f.StringExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newStringFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f StringField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f StringField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f StringField[T]) Name() string {
	return f.column.Name()
}

func (f StringField[T]) Alias() string {
	return f.column.Alias
}

func (f StringField[T]) FullName() string {
	return f.column.FullName()
}

func (f StringField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newStringFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f StringField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) StringField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewStringField[T](tableName.TableName(), name)
}

func (f StringField[T]) WithAlias(alias string) StringField[T] {
	ret := NewStringField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f StringField[T]) FieldType() T {
	var def T
	return def
}

func (f StringField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f StringField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f StringField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f StringField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f StringField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f StringField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateTimeField ====================

type DateTimeField[T any] struct {
	DateTimeExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewDateTimeField[T any](tableName, name string, flags ...types.FieldFlag) DateTimeField[T] {
	ret := newDateTimeFieldFromExpr[T](nil, tableName, name, "")
	ret.DateTimeExpr = DateTimeOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newDateTimeFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) DateTimeField[T] {
	return DateTimeField[T]{
		DateTimeExpr: DateTimeOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f DateTimeField[T]) Build(builder clause.Builder) {
	f.DateTimeExpr.Build(builder)
}

func (f DateTimeField[T]) ToExpr() clause.Expression {
	return f.DateTimeExpr
}

func (f DateTimeField[T]) Unwrap() clause.Expression {
	return f.DateTimeExpr
}

func (f DateTimeField[T]) Expr() DateTimeExpr[T] {
	return f.DateTimeExpr
}

func (f DateTimeField[T]) Wrap(functionName FunctionName) DateTimeField[T] {
	var expr = f.DateTimeExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newDateTimeFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DateTimeField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DateTimeField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DateTimeField[T]) Name() string {
	return f.column.Name()
}

func (f DateTimeField[T]) Alias() string {
	return f.column.Alias
}

func (f DateTimeField[T]) FullName() string {
	return f.column.FullName()
}

func (f DateTimeField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newDateTimeFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f DateTimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateTimeField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateTimeField[T](tableName.TableName(), name)
}

func (f DateTimeField[T]) WithAlias(alias string) DateTimeField[T] {
	ret := NewDateTimeField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f DateTimeField[T]) FieldType() T {
	var def T
	return def
}

func (f DateTimeField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DateTimeField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DateTimeField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DateTimeField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DateTimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateTimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateField ====================

type DateField[T any] struct {
	DateExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewDateField[T any](tableName, name string, flags ...types.FieldFlag) DateField[T] {
	ret := newDateFieldFromExpr[T](nil, tableName, name, "")
	ret.DateExpr = DateOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newDateFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) DateField[T] {
	return DateField[T]{
		DateExpr: DateOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f DateField[T]) Build(builder clause.Builder) {
	f.DateExpr.Build(builder)
}

func (f DateField[T]) ToExpr() clause.Expression {
	return f.DateExpr
}

func (f DateField[T]) Unwrap() clause.Expression {
	return f.DateExpr
}

func (f DateField[T]) Expr() DateExpr[T] {
	return f.DateExpr
}

func (f DateField[T]) Wrap(functionName FunctionName) DateField[T] {
	var expr = f.DateExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newDateFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f DateField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f DateField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f DateField[T]) Name() string {
	return f.column.Name()
}

func (f DateField[T]) Alias() string {
	return f.column.Alias
}

func (f DateField[T]) FullName() string {
	return f.column.FullName()
}

func (f DateField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newDateFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f DateField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateField[T](tableName.TableName(), name)
}

func (f DateField[T]) WithAlias(alias string) DateField[T] {
	ret := NewDateField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f DateField[T]) FieldType() T {
	var def T
	return def
}

func (f DateField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f DateField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f DateField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f DateField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f DateField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== TimeField ====================

type TimeField[T any] struct {
	TimeExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewTimeField[T any](tableName, name string, flags ...types.FieldFlag) TimeField[T] {
	ret := newTimeFieldFromExpr[T](nil, tableName, name, "")
	ret.TimeExpr = TimeOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newTimeFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) TimeField[T] {
	return TimeField[T]{
		TimeExpr: TimeOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f TimeField[T]) Build(builder clause.Builder) {
	f.TimeExpr.Build(builder)
}

func (f TimeField[T]) ToExpr() clause.Expression {
	return f.TimeExpr
}

func (f TimeField[T]) Unwrap() clause.Expression {
	return f.TimeExpr
}

func (f TimeField[T]) Expr() TimeExpr[T] {
	return f.TimeExpr
}

func (f TimeField[T]) Wrap(functionName FunctionName) TimeField[T] {
	var expr = f.TimeExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newTimeFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f TimeField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f TimeField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f TimeField[T]) Name() string {
	return f.column.Name()
}

func (f TimeField[T]) Alias() string {
	return f.column.Alias
}

func (f TimeField[T]) FullName() string {
	return f.column.FullName()
}

func (f TimeField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newTimeFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f TimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TimeField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewTimeField[T](tableName.TableName(), name)
}

func (f TimeField[T]) WithAlias(alias string) TimeField[T] {
	ret := NewTimeField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f TimeField[T]) FieldType() T {
	var def T
	return def
}

func (f TimeField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f TimeField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f TimeField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f TimeField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f TimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== ScalarField ====================

type ScalarField[T any] struct {
	ScalarExpr[T]
	flags  types.FieldFlag
	column *clauses2.ColumnQuote
}

func NewScalarField[T any](tableName, name string, flags ...types.FieldFlag) ScalarField[T] {
	ret := newScalarFieldFromExpr[T](nil, tableName, name, "")
	ret.ScalarExpr = ScalarOf[T](ret.column)
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func newScalarFieldFromExpr[T any](expr clause.Expression, tableName, columnName, alias string) ScalarField[T] {
	return ScalarField[T]{
		ScalarExpr: ScalarOf[T](expr),
		column: &clauses2.ColumnQuote{
			TableName:  tableName,
			ColumnName: columnName,
			Alias:      alias,
		},
		flags: 0,
	}
}

/////////////// base ///////////////

func (f ScalarField[T]) Build(builder clause.Builder) {
	f.ScalarExpr.Build(builder)
}

func (f ScalarField[T]) ToExpr() clause.Expression {
	return f.ScalarExpr
}

func (f ScalarField[T]) Unwrap() clause.Expression {
	return f.ScalarExpr
}

func (f ScalarField[T]) Expr() ScalarExpr[T] {
	return f.ScalarExpr
}

func (f ScalarField[T]) Wrap(functionName FunctionName) ScalarField[T] {
	var expr = f.ScalarExpr.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return newScalarFieldFromExpr[T](e, f.TableName(), f.ColumnName(), "")
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f ScalarField[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f ScalarField[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f ScalarField[T]) Name() string {
	return f.column.Name()
}

func (f ScalarField[T]) Alias() string {
	return f.column.Alias
}

func (f ScalarField[T]) FullName() string {
	return f.column.FullName()
}

func (f ScalarField[T]) As(alias string) fieldi.IField {
	e := fieldImpl{
		expr:  f.Unwrap(),
		alias: alias,
	}
	return newScalarFieldFromExpr[T](e, f.TableName(), f.ColumnName(), alias)
}

func (f ScalarField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) ScalarField[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewScalarField[T](tableName.TableName(), name)
}

func (f ScalarField[T]) WithAlias(alias string) ScalarField[T] {
	ret := NewScalarField[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

/////////////// flags ///////////////

func (f ScalarField[T]) FieldType() T {
	var def T
	return def
}

func (f ScalarField[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f ScalarField[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f ScalarField[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f ScalarField[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f ScalarField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f ScalarField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}
