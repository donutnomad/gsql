// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/field"
	"github.com/donutnomad/gsql/internal/types"
)

// ==================== IntField ====================

type IntField[T any] struct {
	field.Base
	Int[T]
}

func NewIntField[T any](tableName, name string, flags ...field.FieldFlag) IntField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewIntFieldFrom[T](b)
}

func NewIntFieldFrom[T any](f field.IField) IntField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return IntField[T]{
		Base: base,
		Int:  NewInt[T](expr),
	}
}

func (f IntField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f IntField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f IntField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f IntField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) IntField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewIntField[T](tableName.TableName(), name)
}

func (f IntField[T]) WithAlias(alias string) IntField[T] {
	b := f.Base.SetAlias(alias)
	return NewIntFieldFrom[T](b)
}

func (f IntField[T]) FieldType() T {
	var def T
	return def
}

func (f IntField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f IntField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== FloatField ====================

type FloatField[T any] struct {
	field.Base
	Float[T]
}

func NewFloatField[T any](tableName, name string, flags ...field.FieldFlag) FloatField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewFloatFieldFrom[T](b)
}

func NewFloatFieldFrom[T any](f field.IField) FloatField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return FloatField[T]{
		Base:  base,
		Float: NewFloat[T](expr),
	}
}

func (f FloatField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f FloatField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f FloatField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f FloatField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) FloatField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewFloatField[T](tableName.TableName(), name)
}

func (f FloatField[T]) WithAlias(alias string) FloatField[T] {
	b := f.Base.SetAlias(alias)
	return NewFloatFieldFrom[T](b)
}

func (f FloatField[T]) FieldType() T {
	var def T
	return def
}

func (f FloatField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f FloatField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DecimalField ====================

type DecimalField[T any] struct {
	field.Base
	Decimal[T]
}

func NewDecimalField[T any](tableName, name string, flags ...field.FieldFlag) DecimalField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewDecimalFieldFrom[T](b)
}

func NewDecimalFieldFrom[T any](f field.IField) DecimalField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return DecimalField[T]{
		Base:    base,
		Decimal: NewDecimal[T](expr),
	}
}

func (f DecimalField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DecimalField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DecimalField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f DecimalField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DecimalField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDecimalField[T](tableName.TableName(), name)
}

func (f DecimalField[T]) WithAlias(alias string) DecimalField[T] {
	b := f.Base.SetAlias(alias)
	return NewDecimalFieldFrom[T](b)
}

func (f DecimalField[T]) FieldType() T {
	var def T
	return def
}

func (f DecimalField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DecimalField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== StringField ====================

type StringField[T any] struct {
	field.Base
	String[T]
}

func NewStringField[T any](tableName, name string, flags ...field.FieldFlag) StringField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewStringFieldFrom[T](b)
}

func NewStringFieldFrom[T any](f field.IField) StringField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return StringField[T]{
		Base:   base,
		String: NewString[T](expr),
	}
}

func (f StringField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f StringField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f StringField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f StringField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) StringField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewStringField[T](tableName.TableName(), name)
}

func (f StringField[T]) WithAlias(alias string) StringField[T] {
	b := f.Base.SetAlias(alias)
	return NewStringFieldFrom[T](b)
}

func (f StringField[T]) FieldType() T {
	var def T
	return def
}

func (f StringField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f StringField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateTimeField ====================

type DateTimeField[T any] struct {
	field.Base
	DateTime[T]
}

func NewDateTimeField[T any](tableName, name string, flags ...field.FieldFlag) DateTimeField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewDateTimeFieldFrom[T](b)
}

func NewDateTimeFieldFrom[T any](f field.IField) DateTimeField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return DateTimeField[T]{
		Base:     base,
		DateTime: NewDateTime[T](expr),
	}
}

func (f DateTimeField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DateTimeField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DateTimeField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f DateTimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateTimeField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateTimeField[T](tableName.TableName(), name)
}

func (f DateTimeField[T]) WithAlias(alias string) DateTimeField[T] {
	b := f.Base.SetAlias(alias)
	return NewDateTimeFieldFrom[T](b)
}

func (f DateTimeField[T]) FieldType() T {
	var def T
	return def
}

func (f DateTimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateTimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateField ====================

type DateField[T any] struct {
	field.Base
	Date[T]
}

func NewDateField[T any](tableName, name string, flags ...field.FieldFlag) DateField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewDateFieldFrom[T](b)
}

func NewDateFieldFrom[T any](f field.IField) DateField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return DateField[T]{
		Base: base,
		Date: NewDate[T](expr),
	}
}

func (f DateField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DateField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DateField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f DateField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateField[T](tableName.TableName(), name)
}

func (f DateField[T]) WithAlias(alias string) DateField[T] {
	b := f.Base.SetAlias(alias)
	return NewDateFieldFrom[T](b)
}

func (f DateField[T]) FieldType() T {
	var def T
	return def
}

func (f DateField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== TimeField ====================

type TimeField[T any] struct {
	field.Base
	Time[T]
}

func NewTimeField[T any](tableName, name string, flags ...field.FieldFlag) TimeField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewTimeFieldFrom[T](b)
}

func NewTimeFieldFrom[T any](f field.IField) TimeField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return TimeField[T]{
		Base: base,
		Time: NewTime[T](expr),
	}
}

func (f TimeField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f TimeField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f TimeField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f TimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TimeField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewTimeField[T](tableName.TableName(), name)
}

func (f TimeField[T]) WithAlias(alias string) TimeField[T] {
	b := f.Base.SetAlias(alias)
	return NewTimeFieldFrom[T](b)
}

func (f TimeField[T]) FieldType() T {
	var def T
	return def
}

func (f TimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}
