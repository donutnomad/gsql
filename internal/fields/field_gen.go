// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/fieldi"
	"github.com/donutnomad/gsql/internal/types"
)

// ==================== IntField ====================

type IntField[T any] struct {
	fieldi.Base
	IntExpr[T]
}

func NewIntField[T any](tableName, name string, flags ...types.FieldFlag) IntField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewIntFieldFrom[T](b)
}

func NewIntFieldFrom[T any](f fieldi.IField) IntField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return IntField[T]{
		Base:    base,
		IntExpr: IntOf[T](expr),
	}
}

func (f IntField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f IntField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f IntField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f IntField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) IntField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewIntField[T](tableName.TableName(), name)
}

func (f IntField[T]) WithAlias(alias string) IntField[T] {
	b := f.Base.SetAlias(alias)
	return NewIntFieldFrom[T](b)
}

func (f IntField[T]) FieldType() T {
	var def T
	return def
}

func (f IntField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f IntField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f IntField[T]) Wrap(functionName FunctionName) IntField[T] {
	return IntField[T]{
		Base: f.Base,
		IntExpr: IntOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.IntExpr},
		}),
	}
}

// ==================== FloatField ====================

type FloatField[T any] struct {
	fieldi.Base
	FloatExpr[T]
}

func NewFloatField[T any](tableName, name string, flags ...types.FieldFlag) FloatField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewFloatFieldFrom[T](b)
}

func NewFloatFieldFrom[T any](f fieldi.IField) FloatField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return FloatField[T]{
		Base:      base,
		FloatExpr: FloatOf[T](expr),
	}
}

func (f FloatField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f FloatField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f FloatField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f FloatField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) FloatField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewFloatField[T](tableName.TableName(), name)
}

func (f FloatField[T]) WithAlias(alias string) FloatField[T] {
	b := f.Base.SetAlias(alias)
	return NewFloatFieldFrom[T](b)
}

func (f FloatField[T]) FieldType() T {
	var def T
	return def
}

func (f FloatField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f FloatField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f FloatField[T]) Wrap(functionName FunctionName) FloatField[T] {
	return FloatField[T]{
		Base: f.Base,
		FloatExpr: FloatOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.FloatExpr},
		}),
	}
}

// ==================== DecimalField ====================

type DecimalField[T any] struct {
	fieldi.Base
	DecimalExpr[T]
}

func NewDecimalField[T any](tableName, name string, flags ...types.FieldFlag) DecimalField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewDecimalFieldFrom[T](b)
}

func NewDecimalFieldFrom[T any](f fieldi.IField) DecimalField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return DecimalField[T]{
		Base:        base,
		DecimalExpr: DecimalOf[T](expr),
	}
}

func (f DecimalField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DecimalField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DecimalField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f DecimalField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DecimalField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDecimalField[T](tableName.TableName(), name)
}

func (f DecimalField[T]) WithAlias(alias string) DecimalField[T] {
	b := f.Base.SetAlias(alias)
	return NewDecimalFieldFrom[T](b)
}

func (f DecimalField[T]) FieldType() T {
	var def T
	return def
}

func (f DecimalField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DecimalField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f DecimalField[T]) Wrap(functionName FunctionName) DecimalField[T] {
	return DecimalField[T]{
		Base: f.Base,
		DecimalExpr: DecimalOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.DecimalExpr},
		}),
	}
}

// ==================== StringField ====================

type StringField[T any] struct {
	fieldi.Base
	StringExpr[T]
}

func NewStringField[T any](tableName, name string, flags ...types.FieldFlag) StringField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewStringFieldFrom[T](b)
}

func NewStringFieldFrom[T any](f fieldi.IField) StringField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return StringField[T]{
		Base:       base,
		StringExpr: StringOf[T](expr),
	}
}

func (f StringField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f StringField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f StringField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f StringField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) StringField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewStringField[T](tableName.TableName(), name)
}

func (f StringField[T]) WithAlias(alias string) StringField[T] {
	b := f.Base.SetAlias(alias)
	return NewStringFieldFrom[T](b)
}

func (f StringField[T]) FieldType() T {
	var def T
	return def
}

func (f StringField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f StringField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f StringField[T]) Wrap(functionName FunctionName) StringField[T] {
	return StringField[T]{
		Base: f.Base,
		StringExpr: StringOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.StringExpr},
		}),
	}
}

// ==================== DateTimeField ====================

type DateTimeField[T any] struct {
	fieldi.Base
	DateTimeExpr[T]
}

func NewDateTimeField[T any](tableName, name string, flags ...types.FieldFlag) DateTimeField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewDateTimeFieldFrom[T](b)
}

func NewDateTimeFieldFrom[T any](f fieldi.IField) DateTimeField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return DateTimeField[T]{
		Base:         base,
		DateTimeExpr: DateTimeOf[T](expr),
	}
}

func (f DateTimeField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DateTimeField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DateTimeField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f DateTimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateTimeField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateTimeField[T](tableName.TableName(), name)
}

func (f DateTimeField[T]) WithAlias(alias string) DateTimeField[T] {
	b := f.Base.SetAlias(alias)
	return NewDateTimeFieldFrom[T](b)
}

func (f DateTimeField[T]) FieldType() T {
	var def T
	return def
}

func (f DateTimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateTimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f DateTimeField[T]) Wrap(functionName FunctionName) DateTimeField[T] {
	return DateTimeField[T]{
		Base: f.Base,
		DateTimeExpr: DateTimeOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.DateTimeExpr},
		}),
	}
}

// ==================== DateField ====================

type DateField[T any] struct {
	fieldi.Base
	DateExpr[T]
}

func NewDateField[T any](tableName, name string, flags ...types.FieldFlag) DateField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewDateFieldFrom[T](b)
}

func NewDateFieldFrom[T any](f fieldi.IField) DateField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return DateField[T]{
		Base:     base,
		DateExpr: DateOf[T](expr),
	}
}

func (f DateField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DateField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DateField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f DateField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateField[T](tableName.TableName(), name)
}

func (f DateField[T]) WithAlias(alias string) DateField[T] {
	b := f.Base.SetAlias(alias)
	return NewDateFieldFrom[T](b)
}

func (f DateField[T]) FieldType() T {
	var def T
	return def
}

func (f DateField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f DateField[T]) Wrap(functionName FunctionName) DateField[T] {
	return DateField[T]{
		Base: f.Base,
		DateExpr: DateOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.DateExpr},
		}),
	}
}

// ==================== TimeField ====================

type TimeField[T any] struct {
	fieldi.Base
	TimeExpr[T]
}

func NewTimeField[T any](tableName, name string, flags ...types.FieldFlag) TimeField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewTimeFieldFrom[T](b)
}

func NewTimeFieldFrom[T any](f fieldi.IField) TimeField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return TimeField[T]{
		Base:     base,
		TimeExpr: TimeOf[T](expr),
	}
}

func (f TimeField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f TimeField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f TimeField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f TimeField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TimeField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewTimeField[T](tableName.TableName(), name)
}

func (f TimeField[T]) WithAlias(alias string) TimeField[T] {
	b := f.Base.SetAlias(alias)
	return NewTimeFieldFrom[T](b)
}

func (f TimeField[T]) FieldType() T {
	var def T
	return def
}

func (f TimeField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TimeField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f TimeField[T]) Wrap(functionName FunctionName) TimeField[T] {
	return TimeField[T]{
		Base: f.Base,
		TimeExpr: TimeOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.TimeExpr},
		}),
	}
}

// ==================== ScalarField ====================

type ScalarField[T any] struct {
	fieldi.Base
	ScalarExpr[T]
}

func NewScalarField[T any](tableName, name string, flags ...types.FieldFlag) ScalarField[T] {
	b := fieldi.NewBase(tableName, name, flags...)
	return NewScalarFieldFrom[T](b)
}

func NewScalarFieldFrom[T any](f fieldi.IField) ScalarField[T] {
	base := fieldi.IFieldToBase(f)
	expr := base.ToExpr()
	return ScalarField[T]{
		Base:       base,
		ScalarExpr: ScalarOf[T](expr),
	}
}

func (f ScalarField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f ScalarField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f ScalarField[T]) As(alias string) fieldi.IField {
	return f.Base.As(alias)
}

func (f ScalarField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) ScalarField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewScalarField[T](tableName.TableName(), name)
}

func (f ScalarField[T]) WithAlias(alias string) ScalarField[T] {
	b := f.Base.SetAlias(alias)
	return NewScalarFieldFrom[T](b)
}

func (f ScalarField[T]) FieldType() T {
	var def T
	return def
}

func (f ScalarField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f ScalarField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

func (f ScalarField[T]) Wrap(functionName FunctionName) ScalarField[T] {
	return ScalarField[T]{
		Base: f.Base,
		ScalarExpr: ScalarOf[T](clause.Expr{
			SQL:  string(functionName) + "(?)",
			Vars: []any{f.ScalarExpr},
		}),
	}
}
