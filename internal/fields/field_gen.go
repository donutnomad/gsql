// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/field"
	"github.com/donutnomad/gsql/internal/types"
)

// ==================== IntExprField ====================

type IntExprField[T any] struct {
	field.Base
	IntExpr[T]
}

func NewIntExprField[T any](tableName, name string, flags ...field.FieldFlag) IntExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewIntExprFieldFrom[T](b)
}

func NewIntExprFieldFrom[T any](f field.IField) IntExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return IntExprField[T]{
		Base:    base,
		IntExpr: NewIntExpr[T](expr),
	}
}

func (f IntExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f IntExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f IntExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f IntExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) IntExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewIntExprField[T](tableName.TableName(), name)
}

func (f IntExprField[T]) WithAlias(alias string) IntExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewIntExprFieldFrom[T](b)
}

func (f IntExprField[T]) FieldType() T {
	var def T
	return def
}

func (f IntExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f IntExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== FloatExprField ====================

type FloatExprField[T any] struct {
	field.Base
	FloatExpr[T]
}

func NewFloatExprField[T any](tableName, name string, flags ...field.FieldFlag) FloatExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewFloatExprFieldFrom[T](b)
}

func NewFloatExprFieldFrom[T any](f field.IField) FloatExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return FloatExprField[T]{
		Base:      base,
		FloatExpr: NewFloatExpr[T](expr),
	}
}

func (f FloatExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f FloatExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f FloatExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f FloatExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) FloatExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewFloatExprField[T](tableName.TableName(), name)
}

func (f FloatExprField[T]) WithAlias(alias string) FloatExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewFloatExprFieldFrom[T](b)
}

func (f FloatExprField[T]) FieldType() T {
	var def T
	return def
}

func (f FloatExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f FloatExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DecimalExprField ====================

type DecimalExprField[T any] struct {
	field.Base
	DecimalExpr[T]
}

func NewDecimalExprField[T any](tableName, name string, flags ...field.FieldFlag) DecimalExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewDecimalExprFieldFrom[T](b)
}

func NewDecimalExprFieldFrom[T any](f field.IField) DecimalExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return DecimalExprField[T]{
		Base:        base,
		DecimalExpr: NewDecimalExpr[T](expr),
	}
}

func (f DecimalExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DecimalExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DecimalExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f DecimalExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DecimalExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDecimalExprField[T](tableName.TableName(), name)
}

func (f DecimalExprField[T]) WithAlias(alias string) DecimalExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewDecimalExprFieldFrom[T](b)
}

func (f DecimalExprField[T]) FieldType() T {
	var def T
	return def
}

func (f DecimalExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DecimalExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== TextExprField ====================

type TextExprField[T any] struct {
	field.Base
	TextExpr[T]
}

func NewTextExprField[T any](tableName, name string, flags ...field.FieldFlag) TextExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewTextExprFieldFrom[T](b)
}

func NewTextExprFieldFrom[T any](f field.IField) TextExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return TextExprField[T]{
		Base:     base,
		TextExpr: NewTextExpr[T](expr),
	}
}

func (f TextExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f TextExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f TextExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f TextExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TextExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewTextExprField[T](tableName.TableName(), name)
}

func (f TextExprField[T]) WithAlias(alias string) TextExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewTextExprFieldFrom[T](b)
}

func (f TextExprField[T]) FieldType() T {
	var def T
	return def
}

func (f TextExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TextExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateTimeExprField ====================

type DateTimeExprField[T any] struct {
	field.Base
	DateTimeExpr[T]
}

func NewDateTimeExprField[T any](tableName, name string, flags ...field.FieldFlag) DateTimeExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewDateTimeExprFieldFrom[T](b)
}

func NewDateTimeExprFieldFrom[T any](f field.IField) DateTimeExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return DateTimeExprField[T]{
		Base:         base,
		DateTimeExpr: NewDateTimeExpr[T](expr),
	}
}

func (f DateTimeExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DateTimeExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DateTimeExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f DateTimeExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateTimeExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateTimeExprField[T](tableName.TableName(), name)
}

func (f DateTimeExprField[T]) WithAlias(alias string) DateTimeExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewDateTimeExprFieldFrom[T](b)
}

func (f DateTimeExprField[T]) FieldType() T {
	var def T
	return def
}

func (f DateTimeExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateTimeExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== DateExprField ====================

type DateExprField[T any] struct {
	field.Base
	DateExpr[T]
}

func NewDateExprField[T any](tableName, name string, flags ...field.FieldFlag) DateExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewDateExprFieldFrom[T](b)
}

func NewDateExprFieldFrom[T any](f field.IField) DateExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return DateExprField[T]{
		Base:     base,
		DateExpr: NewDateExpr[T](expr),
	}
}

func (f DateExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f DateExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f DateExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f DateExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) DateExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewDateExprField[T](tableName.TableName(), name)
}

func (f DateExprField[T]) WithAlias(alias string) DateExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewDateExprFieldFrom[T](b)
}

func (f DateExprField[T]) FieldType() T {
	var def T
	return def
}

func (f DateExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f DateExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== TimeExprField ====================

type TimeExprField[T any] struct {
	field.Base
	TimeExpr[T]
}

func NewTimeExprField[T any](tableName, name string, flags ...field.FieldFlag) TimeExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewTimeExprFieldFrom[T](b)
}

func NewTimeExprFieldFrom[T any](f field.IField) TimeExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return TimeExprField[T]{
		Base:     base,
		TimeExpr: NewTimeExpr[T](expr),
	}
}

func (f TimeExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f TimeExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f TimeExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f TimeExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TimeExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewTimeExprField[T](tableName.TableName(), name)
}

func (f TimeExprField[T]) WithAlias(alias string) TimeExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewTimeExprFieldFrom[T](b)
}

func (f TimeExprField[T]) FieldType() T {
	var def T
	return def
}

func (f TimeExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TimeExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

// ==================== TimestampExprField ====================

type TimestampExprField[T any] struct {
	field.Base
	TimestampExpr[T]
}

func NewTimestampExprField[T any](tableName, name string, flags ...field.FieldFlag) TimestampExprField[T] {
	b := field.NewBase(tableName, name, flags...)
	return NewTimestampExprFieldFrom[T](b)
}

func NewTimestampExprFieldFrom[T any](f field.IField) TimestampExprField[T] {
	base := field.IFieldToBase(f)
	expr := base.ToExpr()
	return TimestampExprField[T]{
		Base:          base,
		TimestampExpr: NewTimestampExpr[T](expr),
	}
}

func (f TimestampExprField[T]) Build(builder clause.Builder) {
	f.Base.ToExpr().Build(builder)
}

func (f TimestampExprField[T]) ToExpr() clause.Expression {
	return f.Base.ToExpr()
}

func (f TimestampExprField[T]) As(alias string) field.IField {
	return f.Base.As(alias)
}

func (f TimestampExprField[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) TimestampExprField[T] {
	name := f.Base.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return NewTimestampExprField[T](tableName.TableName(), name)
}

func (f TimestampExprField[T]) WithAlias(alias string) TimestampExprField[T] {
	b := f.Base.SetAlias(alias)
	return NewTimestampExprFieldFrom[T](b)
}

func (f TimestampExprField[T]) FieldType() T {
	var def T
	return def
}

func (f TimestampExprField[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f TimestampExprField[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}
