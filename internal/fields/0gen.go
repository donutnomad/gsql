//go:build gen

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"

	"github.com/donutnomad/gsql/internal/genutils"
)

const report = true

type FieldType struct {
	Name      string // e.g., "IntField"
	InnerExpr string // e.g., "IntExpr"
	InnerName string // e.g., "IntExpr" (field name in struct)
	Column    string
	Methods   []ExprMethod // collected methods from InnerExpr
}

// ExprMethod represents a public method of an Expr type
type ExprMethod struct {
	Name     string   // method name, e.g., "Add", "AsFloat"
	Params   []Param  // parameter list
	Results  []string // return type list
	Comments []string // method comments (documentation)
}

// Param represents a method parameter
type Param struct {
	Name string // parameter name
	Type string // parameter type
}

var fieldTypes = []FieldType{
	newFieldType("IntExpr"),
	newFieldType("FloatExpr"),
	newFieldType("DecimalExpr"),
	newFieldType("StringExpr"),
	newFieldType("DateTimeExpr"),
	newFieldType("DateExpr"),
	newFieldType("TimeExpr"),
	newFieldType("ScalarExpr"),
}

func newFieldType(input string) FieldType {
	a := strings.TrimSuffix(input, "Expr") + "Field"
	return FieldType{
		Name:      a,
		InnerExpr: strings.TrimSuffix(input, "Expr"),
		InnerName: input,
		Column:    strings.TrimSuffix(input, "Expr") + "Column",
		Methods:   nil, // Will be populated by collectExprMethods
	}
}

const tpl = `// Code generated by go run gen.go; DO NOT EDIT.

package fields

import (
	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/clauses2"
	"github.com/donutnomad/gsql/internal/fieldi"
	"github.com/donutnomad/gsql/internal/types"{{if needsMo .}}
	"github.com/samber/mo"{{end}}
)

{{range .}}
// ==================== {{.Name}} ====================

type {{.Name}}[T any] struct {
	{{.InnerName | camel}}[T]
	flags types.FieldFlag
	column *clauses2.ColumnQuote
}

func {{.Name}}Of[T any](tableName, name string, flags ...types.FieldFlag) {{.Name}}[T] {
	q := &clauses2.ColumnQuote{
		TableName:  tableName,
		ColumnName: name,
		Alias:      "",
	}
	ret := {{.Name}}[T]{
		{{.InnerName | camel}}: {{.InnerExpr}}Of[T](q),
		column: q,
		flags: 0,
	}
	if len(flags) > 0 {
		ret.flags = flags[0]
	}
	return ret
}

func {{.Column}}[T any](name string) {{.Column}}Builder[T] {
	return {{.Column}}Builder[T]{name: name}
}

type {{.Column}}Builder[T any] struct {
	name string
}

func (b {{.Column}}Builder[T]) From(source interface{ TableName() string }) {{.Name}}[T] {
	return {{.Name}}Of[T](source.TableName(), b.name)
}

/////////////// base ///////////////

func (f {{.Name}}[T]) Build(builder clause.Builder) {
	f.{{.InnerName | camel}}.Build(builder)
}

func (f {{.Name}}[T]) ToExpr() clause.Expression {
	return f.{{.InnerName | camel}}
}

func (f {{.Name}}[T]) Unwrap() clause.Expression {
	return f.{{.InnerName | camel}}
}

func (f {{.Name}}[T]) Expr() {{.InnerName}}[T] {
	return f.{{.InnerName | camel}}
}

func (f {{.Name}}[T]) Apply(functionName FunctionName) {{.InnerName}}[T] {
	var expr = f.{{.InnerName | camel}}.Unwrap()
	if v, ok := expr.(*clauses2.ColumnQuote); ok {
		v.NoAS()
	}
	e := clause.Expr{
		SQL:  string(functionName) + "(?)",
		Vars: []any{expr},
	}
	return {{.InnerExpr}}Of[T](e)
}

/////////////// column-name ///////////////

// TableName 返回表名
func (f {{.Name}}[T]) TableName() string {
	return f.column.TableName
}

// ColumnName 返回列名
func (f {{.Name}}[T]) ColumnName() string {
	return f.column.ColumnName
}

// Name 返回字段名称
// 对于expr，返回别名
// 对于普通字段，有别名的返回别名，否则返回真实名字
func (f {{.Name}}[T]) Name() string {
	return f.column.Name()
}

func (f {{.Name}}[T]) Alias() string {
	return f.column.Alias
}

func (f {{.Name}}[T]) FullName() string {
	return f.column.FullName()
}

func (f {{.Name}}[T]) As(alias string) fieldi.IField {
	return f.WithAlias(alias)
}

func (f {{.Name}}[T]) WithAlias(alias string) {{.Name}}[T] {
	ret := {{.Name}}Of[T](f.TableName(), f.ColumnName(), f.flags)
	ret.column.Alias = alias
	return ret
}

func (f {{.Name}}[T]) WithTable(tableName interface{ TableName() string }, fieldNames ...string) {{.Name}}[T] {
	name := f.ColumnName()
	if len(fieldNames) > 0 {
		name = fieldNames[0]
	}
	return {{.Name}}Of[T](tableName.TableName(), name, f.flags)
}

/////////////// flags ///////////////

func (f {{.Name}}[T]) FieldType() T {
	var def T
	return def
}

func (f {{.Name}}[T]) Flags() types.FieldFlag {
	return f.flags
}

func (f {{.Name}}[T]) HasFlag(flag types.FieldFlag) bool {
	return f.flags&flag != 0
}

func (f {{.Name}}[T]) IsPrimaryKey() bool {
	return f.HasFlag(types.FlagPrimaryKey)
}

func (f {{.Name}}[T]) IsUniqueIndex() bool {
	return f.HasFlag(types.FlagUniqueIndex)
}

/////////////// asc/desc ///////////////

func (f {{.Name}}[T]) Asc() types.OrderItem {
	return types.NewOrder(f, true)
}

func (f {{.Name}}[T]) Desc() types.OrderItem {
	return types.NewOrder(f, false)
}

{{if .Methods}}
/////////////// re-exported methods from {{.InnerName}} ///////////////
{{$fieldType := .}}{{range .Methods}}
{{range .Comments}}// {{.}}
{{end}}func (f {{$fieldType.Name}}[T]) {{.Name}}({{formatParams .Params}}){{formatResults .Results}} {
	return f.{{$fieldType.InnerName}}.{{.Name}}({{formatArgs .Params}})
}

{{end}}{{end}}
{{end}}
`

func main() {
	// Collect methods for each FieldType only when report is true
	if report {
		for i := range fieldTypes {
			fieldTypes[i].Methods = collectExprMethods(fieldTypes[i].InnerName)
		}
	}

	funcMap := template.FuncMap{
		"camel": func(s string) string {
			return s
			//return strings.ToLower(s[0:1]) + s[1:]
		},
		"trimSuffix": func(suffix, s string) string {
			return strings.TrimSuffix(s, suffix)
		},
		"formatParams":  formatParams,
		"formatArgs":    formatArgs,
		"formatResults": formatResults,
		"needsMo": func(types []FieldType) bool {
			for _, t := range types {
				if len(t.Methods) > 0 {
					return true
				}
			}
			return false
		},
	}
	t := template.Must(template.New("fields").Funcs(funcMap).Parse(tpl))

	var buf bytes.Buffer
	if err := t.Execute(&buf, fieldTypes); err != nil {
		panic(err)
	}

	fileName := "field_generate.go"
	if err := genutils.WriteFormat(fileName, buf.Bytes()); err != nil {
		panic(err)
	}
	fmt.Println("Generated " + fileName + " successfully")
}

// formatParams formats the parameter list as a string for function signature
func formatParams(params []Param) string {
	if len(params) == 0 {
		return ""
	}
	var parts []string
	for _, p := range params {
		parts = append(parts, p.Name+" "+p.Type)
	}
	return strings.Join(parts, ", ")
}

// formatArgs formats the parameter names for function call
func formatArgs(params []Param) string {
	if len(params) == 0 {
		return ""
	}
	var parts []string
	for _, p := range params {
		// Handle variadic parameters
		if strings.HasPrefix(p.Type, "...") {
			parts = append(parts, p.Name+"...")
		} else {
			parts = append(parts, p.Name)
		}
	}
	return strings.Join(parts, ", ")
}

// formatResults formats the return type list
func formatResults(results []string) string {
	if len(results) == 0 {
		return ""
	}
	if len(results) == 1 {
		return " " + results[0]
	}
	return " (" + strings.Join(results, ", ") + ")"
}

// collectExprMethods collects all exported methods from the given Expr type
// including methods from embedded types (recursively)
func collectExprMethods(exprTypeName string) []ExprMethod {
	var methods []ExprMethod
	seen := make(map[string]bool) // Avoid duplicate methods

	// Determine source file names (e.g., IntExpr -> int.go, int_generate.go)
	baseName := strings.ToLower(strings.TrimSuffix(exprTypeName, "Expr"))
	sourceFiles := []string{
		baseName + ".go",
		baseName + "_generate.go",
	}

	// Parse each source file for the Expr type's own methods
	for _, fileName := range sourceFiles {
		if _, err := os.Stat(fileName); os.IsNotExist(err) {
			continue // File doesn't exist, skip
		}

		fileMethods := parseMethodsFromFile(fileName, exprTypeName)
		for _, m := range fileMethods {
			if !seen[m.Name] {
				seen[m.Name] = true
				methods = append(methods, m)
			}
		}
	}

	// Get embedded types from the Expr type definition
	embeddedTypes := getEmbeddedTypes(baseName+".go", exprTypeName)

	// Recursively collect methods from embedded types (from numeric_base.go)
	processedTypes := make(map[string]bool)
	var collectEmbeddedMethods func(types []string)
	collectEmbeddedMethods = func(types []string) {
		for _, embType := range types {
			if processedTypes[embType] {
				continue
			}
			processedTypes[embType] = true

			// Collect methods from this embedded type
			embMethods := parseMethodsFromFile("numeric_base.go", embType)
			for _, m := range embMethods {
				if !seen[m.Name] && !isSpecialMethod(m.Name) {
					seen[m.Name] = true
					methods = append(methods, m)
				}
			}

			// Recursively process nested embedded types
			nestedTypes := getEmbeddedTypes("numeric_base.go", embType)
			if len(nestedTypes) > 0 {
				collectEmbeddedMethods(nestedTypes)
			}
		}
	}
	collectEmbeddedMethods(embeddedTypes)

	return methods
}

// getEmbeddedTypes parses a file and returns the embedded type names for the given struct type
func getEmbeddedTypes(fileName, typeName string) []string {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, fileName, nil, 0)
	if err != nil {
		return nil
	}

	var embeddedTypes []string

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Check if this is the type we're looking for (handle generic types)
			specTypeName := typeSpec.Name.Name
			if specTypeName != typeName {
				continue
			}

			// Get the struct type
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// Collect embedded type names
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					// This is an embedded field
					embTypeName := getEmbeddedTypeName(field.Type)
					if embTypeName != "" {
						embeddedTypes = append(embeddedTypes, embTypeName)
					}
				}
			}
		}
	}

	return embeddedTypes
}

// getEmbeddedTypeName extracts the type name from an embedded field expression
func getEmbeddedTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.IndexExpr:
		// Generic type, e.g., baseComparableImpl[T]
		if ident, ok := t.X.(*ast.Ident); ok {
			return ident.Name
		}
	case *ast.SelectorExpr:
		// Qualified type, e.g., pkg.Type
		return t.Sel.Name
	}
	return ""
}

// parseMethodsFromFile parses all exported methods from a source file for the given type
func parseMethodsFromFile(fileName, typeName string) []ExprMethod {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing %s: %v\n", fileName, err)
		return nil
	}

	var methods []ExprMethod

	for _, decl := range node.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {
			continue
		}

		// Check if the receiver type matches
		recvType := getReceiverTypeName(fn.Recv.List[0].Type)
		if recvType != typeName {
			continue
		}

		// Only collect exported methods (starts with uppercase)
		if !ast.IsExported(fn.Name.Name) {
			continue
		}

		// Skip special methods that are already handled in the template
		if isSpecialMethod(fn.Name.Name) {
			continue
		}

		method := ExprMethod{
			Name:     fn.Name.Name,
			Params:   parseMethodParams(fn.Type.Params),
			Results:  parseMethodResults(fn.Type.Results),
			Comments: extractComments(fn.Doc),
		}

		methods = append(methods, method)
	}

	return methods
}

// isSpecialMethod checks if a method should be skipped (already handled in template)
func isSpecialMethod(name string) bool {
	specialMethods := map[string]bool{
		"Build":  true,
		"ToExpr": true,
		"Unwrap": true,
		"As":     true,
	}
	return specialMethods[name]
}

// getReceiverTypeName extracts the type name from the receiver expression
func getReceiverTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.StarExpr:
		return getReceiverTypeName(t.X)
	case *ast.Ident:
		return t.Name
	case *ast.IndexExpr:
		// Generic type, e.g., IntExpr[T]
		if ident, ok := t.X.(*ast.Ident); ok {
			return ident.Name
		}
	}
	return ""
}

// parseMethodParams parses the method parameters
func parseMethodParams(params *ast.FieldList) []Param {
	if params == nil || len(params.List) == 0 {
		return nil
	}

	var result []Param
	for _, field := range params.List {
		typeStr := exprToTypeString(field.Type)
		if len(field.Names) == 0 {
			// Unnamed parameter, generate a name
			result = append(result, Param{
				Name: fmt.Sprintf("arg%d", len(result)),
				Type: typeStr,
			})
		} else {
			for _, name := range field.Names {
				result = append(result, Param{
					Name: name.Name,
					Type: typeStr,
				})
			}
		}
	}
	return result
}

// parseMethodResults parses the method return types
func parseMethodResults(results *ast.FieldList) []string {
	if results == nil || len(results.List) == 0 {
		return nil
	}

	var result []string
	for _, field := range results.List {
		result = append(result, exprToTypeString(field.Type))
	}
	return result
}

// exprToTypeString converts an AST expression to a type string
func exprToTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return exprToTypeString(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + exprToTypeString(t.X)
	case *ast.ArrayType:
		return "[]" + exprToTypeString(t.Elt)
	case *ast.Ellipsis:
		return "..." + exprToTypeString(t.Elt)
	case *ast.IndexExpr:
		return exprToTypeString(t.X) + "[" + exprToTypeString(t.Index) + "]"
	case *ast.InterfaceType:
		return "any"
	case *ast.MapType:
		return "map[" + exprToTypeString(t.Key) + "]" + exprToTypeString(t.Value)
	case *ast.FuncType:
		return "func" + formatFuncType(t)
	case *ast.ChanType:
		return "chan " + exprToTypeString(t.Value)
	}
	return "any"
}

// formatFuncType formats a function type (for func parameters/returns)
func formatFuncType(ft *ast.FuncType) string {
	var params, results []string
	if ft.Params != nil {
		for _, p := range ft.Params.List {
			params = append(params, exprToTypeString(p.Type))
		}
	}
	if ft.Results != nil {
		for _, r := range ft.Results.List {
			results = append(results, exprToTypeString(r.Type))
		}
	}

	result := "(" + strings.Join(params, ", ") + ")"
	if len(results) == 1 {
		result += " " + results[0]
	} else if len(results) > 1 {
		result += " (" + strings.Join(results, ", ") + ")"
	}
	return result
}

// extractComments extracts the comment text from a CommentGroup
func extractComments(doc *ast.CommentGroup) []string {
	if doc == nil {
		return nil
	}

	var comments []string
	for _, c := range doc.List {
		text := strings.TrimPrefix(c.Text, "//")
		text = strings.TrimSpace(text)
		if text != "" && !strings.HasPrefix(text, "@") {
			// Skip @gen directive comments
			comments = append(comments, text)
		}
	}
	return comments
}
