// Code generated by export-types. DO NOT EDIT.
// Source: github.com/donutnomad/gsql/internal/fields

package gsql

import (
	"database/sql"
	"time"

	"github.com/donutnomad/gsql/clause"
	"github.com/donutnomad/gsql/internal/fields"
	"github.com/donutnomad/gsql/internal/types"
)

// ==================== Constructors ====================

func NewLitExpr[T any](value T) *fields.LitExpr {
	return fields.NewLitExpr[T](value)
}

func BoolColumn(name string) fields.ScalarColumnBuilder[bool] {
	return fields.BoolColumn(name)
}

func CastExpr[Expr interface{ ExprType() R }, R any](v clause.Expression) Expr {
	return fields.CastExpr[Expr, R](v)
}

func Column[T any](name string) fields.ScalarColumnBuilder[T] {
	return fields.Column[T](name)
}

// Date creates a DateExpr[string] from a clause expression.
func Date(expr clause.Expression) fields.DateExpr[time.Time] {
	return fields.Date(expr)
}

func DateColumn[T any](name string) fields.DateColumnBuilder[T] {
	return fields.DateColumn[T](name)
}

// DateE creates a DateExpr[string] from raw SQL with optional variables.
func DateE(sql string, vars ...any) fields.DateExpr[string] {
	return fields.DateE(sql, vars...)
}

func DateFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.DateField[T] {
	return fields.DateFieldOf[T](tableName, name, flags...)
}

func DateFrom[T any](field interface{ FieldType() T }) fields.DateExpr[T] {
	return fields.DateFrom[T](field)
}

// DateOf creates a generic DateExpr[T] from a clause expression.
func DateOf[T any](expr clause.Expression) fields.DateExpr[T] {
	return fields.DateOf[T](expr)
}

// DateTime creates a DateTimeExpr[string] from a clause expression.
func DateTime(expr clause.Expression) fields.DateTimeExpr[time.Time] {
	return fields.DateTime(expr)
}

func DateTimeColumn[T any](name string) fields.DateTimeColumnBuilder[T] {
	return fields.DateTimeColumn[T](name)
}

// DateTimeE creates a DateTimeExpr[string] from raw SQL with optional variables.
func DateTimeE(sql string, vars ...any) fields.DateTimeExpr[string] {
	return fields.DateTimeE(sql, vars...)
}

func DateTimeFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.DateTimeField[T] {
	return fields.DateTimeFieldOf[T](tableName, name, flags...)
}

func DateTimeFrom[T any](field interface{ FieldType() T }) fields.DateTimeExpr[T] {
	return fields.DateTimeFrom[T](field)
}

// DateTimeOf creates a generic DateTimeExpr[T] from a clause expression.
func DateTimeOf[T any](expr clause.Expression) fields.DateTimeExpr[T] {
	return fields.DateTimeOf[T](expr)
}

// DateTimeVal creates a DateTimeExpr from a datetime literal value.
func DateTimeVal[T string | time.Time | *time.Time | sql.NullTime | any](val T) fields.DateTimeExpr[T] {
	return fields.DateTimeVal[T](val)
}

// DateVal creates a DateExpr from a date literal value.
func DateVal[T ~string | time.Time | *time.Time | sql.NullTime | any](val T) fields.DateExpr[T] {
	return fields.DateVal[T](val)
}

// Decimal creates a DecimalExpr[float64] from a clause expression.
func Decimal(expr clause.Expression) fields.DecimalExpr[float64] {
	return fields.Decimal(expr)
}

func DecimalColumn[T any](name string) fields.DecimalColumnBuilder[T] {
	return fields.DecimalColumn[T](name)
}

// DecimalE creates a DecimalExpr[float64] from raw SQL with optional variables.
func DecimalE(sql string, vars ...any) fields.DecimalExpr[float64] {
	return fields.DecimalE(sql, vars...)
}

func DecimalFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.DecimalField[T] {
	return fields.DecimalFieldOf[T](tableName, name, flags...)
}

func DecimalFrom[T any](field interface{ FieldType() T }) fields.DecimalExpr[T] {
	return fields.DecimalFrom[T](field)
}

// DecimalOf creates a generic DecimalExpr[T] from a clause expression.
func DecimalOf[T any](expr clause.Expression) fields.DecimalExpr[T] {
	return fields.DecimalOf[T](expr)
}

// DecimalVal creates a DecimalExpr from a floating-point literal value.
func DecimalVal[T ~float32 | ~float64 | any](val T) fields.DecimalExpr[T] {
	return fields.DecimalVal[T](val)
}

// Float creates a FloatExpr[float64] from a clause expression.
func Float(expr clause.Expression) fields.FloatExpr[float64] {
	return fields.Float(expr)
}

func FloatColumn[T any](name string) fields.FloatColumnBuilder[T] {
	return fields.FloatColumn[T](name)
}

// FloatE creates a FloatExpr[float64] from raw SQL with optional variables.
func FloatE(sql string, vars ...any) fields.FloatExpr[float64] {
	return fields.FloatE(sql, vars...)
}

func FloatFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.FloatField[T] {
	return fields.FloatFieldOf[T](tableName, name, flags...)
}

func FloatFrom[T any](field interface{ FieldType() T }) fields.FloatExpr[T] {
	return fields.FloatFrom[T](field)
}

// FloatOf creates a generic FloatExpr[T] from a clause expression.
func FloatOf[T any](expr clause.Expression) fields.FloatExpr[T] {
	return fields.FloatOf[T](expr)
}

// FloatVal creates a FloatExpr from a floating-point literal value.
func FloatVal[T ~float32 | ~float64 | any](val T) fields.FloatExpr[T] {
	return fields.FloatVal[T](val)
}

// Int creates an IntExpr[int64] from a clause expression.
func Int(expr clause.Expression) fields.IntExpr[int64] {
	return fields.Int(expr)
}

func IntColumn[T any](name string) fields.IntColumnBuilder[T] {
	return fields.IntColumn[T](name)
}

func IntFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.IntField[T] {
	return fields.IntFieldOf[T](tableName, name, flags...)
}

func IntFrom[T any](field interface{ FieldType() T }) fields.IntExpr[T] {
	return fields.IntFrom[T](field)
}

// IntOf creates a generic IntExpr[T] from a clause expression.
func IntOf[T any](expr clause.Expression) fields.IntExpr[T] {
	return fields.IntOf[T](expr)
}

// IntVal creates an IntExpr from a signed integer literal value.
func IntVal[T ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | any](val T) fields.IntExpr[T] {
	return fields.IntVal[T](val)
}

func Json[T any](val T) fields.JsonExpr {
	return fields.Json[T](val)
}

// JsonArrayAgg 将列值聚合为 JSON 数组 (JSON_ARRAYAGG, MySQL 8.0+)
// SELECT JSON_ARRAYAGG(name) FROM users;
// SELECT department, JSON_ARRAYAGG(name) FROM users GROUP BY department;
// 示例: fields.JsonArrayAgg(u.Name)
func JsonArrayAgg(expr clause.Expression) fields.JsonExpr {
	return fields.JsonArrayAgg(expr)
}

func JsonColumn[T any](name string) fields.JsonColumnBuilder[T] {
	return fields.JsonColumn[T](name)
}

func JsonFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.JsonField[T] {
	return fields.JsonFieldOf[T](tableName, name, flags...)
}

func JsonFrom[T any](field interface{ FieldType() T }) fields.JsonExpr {
	return fields.JsonFrom[T](field)
}

// JsonObjectAgg 将键值对聚合为 JSON 对象 (JSON_OBJECTAGG, MySQL 8.0+)
// SELECT JSON_OBJECTAGG(name, age) FROM users;
// SELECT department, JSON_OBJECTAGG(name, salary) FROM users GROUP BY department;
// 示例: fields.JsonObjectAgg(u.Name, u.Age)
//  1. 键必须唯一 - 如果同一组内有重复的键，后面的值会覆盖前面的
//  2. 键必须是字符串 - MySQL 会自动将非字符串键转换为字符串
//  3. NULL 值 - 如果键为 NULL，该行会被忽略
func JsonObjectAgg(key, value clause.Expression) fields.JsonExpr {
	return fields.JsonObjectAgg(key, value)
}

func ScalarColumn[T any](name string) fields.ScalarColumnBuilder[T] {
	return fields.ScalarColumn[T](name)
}

func ScalarFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.ScalarField[T] {
	return fields.ScalarFieldOf[T](tableName, name, flags...)
}

func ScalarFrom[T any](field interface{ FieldType() T }) fields.ScalarExpr[T] {
	return fields.ScalarFrom[T](field)
}

func ScalarOf[T any](expr clause.Expression) fields.ScalarExpr[T] {
	return fields.ScalarOf[T](expr)
}

// ScalarVal creates a ScalarExpr from a literal value.
func ScalarVal[T any](val T) fields.ScalarExpr[T] {
	return fields.ScalarVal[T](val)
}

// String creates a StringExpr[string] from a clause expression.
func String(expr clause.Expression) fields.StringExpr[string] {
	return fields.String(expr)
}

func StringColumn[T any](name string) fields.StringColumnBuilder[T] {
	return fields.StringColumn[T](name)
}

// StringE creates a StringExpr[string] from raw SQL with optional variables.
func StringE(sql string, vars ...any) fields.StringExpr[string] {
	return fields.StringE(sql, vars...)
}

func StringFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.StringField[T] {
	return fields.StringFieldOf[T](tableName, name, flags...)
}

func StringFrom[T any](field interface{ FieldType() T }) fields.StringExpr[T] {
	return fields.StringFrom[T](field)
}

// StringOf creates a generic StringExpr[T] from a clause expression.
func StringOf[T any](expr clause.Expression) fields.StringExpr[T] {
	return fields.StringOf[T](expr)
}

// StringVal creates a StringExpr from a string literal value.
func StringVal[T ~string | any](val T) fields.StringExpr[T] {
	return fields.StringVal[T](val)
}

// Time creates a TimeExpr[string] from a clause expression.
func Time(expr clause.Expression) fields.TimeExpr[time.Time] {
	return fields.Time(expr)
}

func TimeColumn[T any](name string) fields.TimeColumnBuilder[T] {
	return fields.TimeColumn[T](name)
}

// TimeE creates a TimeExpr[string] from raw SQL with optional variables.
func TimeE(sql string, vars ...any) fields.TimeExpr[string] {
	return fields.TimeE(sql, vars...)
}

func TimeFieldOf[T any](tableName, name string, flags ...types.FieldFlag) fields.TimeField[T] {
	return fields.TimeFieldOf[T](tableName, name, flags...)
}

func TimeFrom[T any](field interface{ FieldType() T }) fields.TimeExpr[T] {
	return fields.TimeFrom[T](field)
}

// TimeOf creates a generic TimeExpr[T] from a clause expression.
func TimeOf[T any](expr clause.Expression) fields.TimeExpr[T] {
	return fields.TimeOf[T](expr)
}

// TimeVal creates a TimeExpr from a time literal value.
func TimeVal[T ~string | time.Time | *time.Time | sql.NullTime | any](val T) fields.TimeExpr[T] {
	return fields.TimeVal[T](val)
}

// Uint creates an IntExpr[uint64] from a clause expression.
func Uint(expr clause.Expression) fields.IntExpr[uint64] {
	return fields.Uint(expr)
}

// Year creates a YearExpr[int64] from a clause expression.
func Year(expr clause.Expression) fields.YearExpr[int64] {
	return fields.Year(expr)
}

// YearE creates a YearExpr[int64] from raw SQL with optional variables.
func YearE(sql string, vars ...any) fields.YearExpr[int64] {
	return fields.YearE(sql, vars...)
}

func YearFrom[T any](field interface{ FieldType() T }) fields.YearExpr[T] {
	return fields.YearFrom[T](field)
}

// YearOf creates a generic YearExpr[T] from a clause expression.
func YearOf[T any](expr clause.Expression) fields.YearExpr[T] {
	return fields.YearOf[T](expr)
}

// YearVal creates a YearExpr from an integer literal value.
func YearVal[T ~int | ~int16 | ~int32 | ~int64 | any](val T) fields.YearExpr[T] {
	return fields.YearVal[T](val)
}

// ==================== Type Aliases ====================

type (
	BaseFields                   = fields.BaseFields
	Condition                    = fields.Condition
	DateColumnBuilder[T any]     = fields.DateColumnBuilder[T]
	DateExpr[T any]              = fields.DateExpr[T]
	DateField[T any]             = fields.DateField[T]
	DateTimeColumnBuilder[T any] = fields.DateTimeColumnBuilder[T]
	DateTimeExpr[T any]          = fields.DateTimeExpr[T]
	DateTimeField[T any]         = fields.DateTimeField[T]
	DecimalColumnBuilder[T any]  = fields.DecimalColumnBuilder[T]
	DecimalExpr[T any]           = fields.DecimalExpr[T]
	DecimalField[T any]          = fields.DecimalField[T]
	Expressions[T any]           = fields.Expressions[T]
	FloatColumnBuilder[T any]    = fields.FloatColumnBuilder[T]
	FloatExpr[T any]             = fields.FloatExpr[T]
	FloatField[T any]            = fields.FloatField[T]
	FunctionName                 = fields.FunctionName
	IntColumnBuilder[T any]      = fields.IntColumnBuilder[T]
	IntConstraint                = fields.IntConstraint
	IntExpr[T any]               = fields.IntExpr[T]
	IntField[T any]              = fields.IntField[T]
	JsonColumnBuilder[T any]     = fields.JsonColumnBuilder[T]
	JsonExpr                     = fields.JsonExpr
	JsonField[T any]             = fields.JsonField[T]
	JsonInput                    = fields.JsonInput
	LitExpr                      = fields.LitExpr
	ScalarColumnBuilder[T any]   = fields.ScalarColumnBuilder[T]
	ScalarExpr[T any]            = fields.ScalarExpr[T]
	ScalarField[T any]           = fields.ScalarField[T]
	StringColumnBuilder[T any]   = fields.StringColumnBuilder[T]
	StringExpr[T any]            = fields.StringExpr[T]
	StringField[T any]           = fields.StringField[T]
	TimeColumnBuilder[T any]     = fields.TimeColumnBuilder[T]
	TimeExpr[T any]              = fields.TimeExpr[T]
	TimeField[T any]             = fields.TimeField[T]
	YearExpr[T any]              = fields.YearExpr[T]
)
